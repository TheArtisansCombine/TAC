<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decido - Let Fate Decide!</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f4f8; /* Light blue-gray background */
            margin: 0;
        }
        /* Custom message box styling (instead of alert()) */
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            font-weight: 600;
        }
        .message-box.show {
            opacity: 1;
        }

        /* Basic animation for coin flip and die roll - placeholder for now */
        .decision-display {
            min-height: 12rem; /* Ensure space for animation */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1.5rem; /* Space between multiple coins/dice/spinners */
            flex-wrap: wrap; /* Allow items to wrap on smaller screens */
            font-size: 2.5rem;
            font-weight: 700;
            color: #2d3748; /* Darker text */
        }

        /* CSS for the coin flip animation */
        .coin {
            width: 80px;
            height: 80px;
            background-color: #fcd34d; /* Gold-like color */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 700;
            color: #3b444b;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            transform-style: preserve-3d;
            animation: none; /* Controlled by JS */
            cursor: pointer; /* Indicate it's clickable */
            border: 2px solid transparent; /* Subtle border for hover */
            transition: border-color 0.2s ease-in-out;
        }
        .coin:hover {
            border-color: #d97706; /* Amber-600 on hover */
        }
        /* Removed .coin.selected style */

        .coin.flipping {
            animation: flip 1s ease-out forwards;
        }

        @keyframes flip {
            0% { transform: rotateX(0deg); }
            50% { transform: rotateX(1800deg); } /* Multiple spins */
            100% { transform: rotateX(3600deg); }
        }

        /* CSS for the die roll animation (simple version) */
        .die {
            width: 80px;
            height: 80px;
            background-color: #e2e8f0; /* Light gray */
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: 700;
            color: #2d3748;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            animation: none; /* Controlled by JS */
            cursor: pointer; /* Indicate it's clickable */
            border: 2px solid transparent; /* Subtle border for hover */
            transition: border-color 0.2s ease-in-out;
        }
        .die:hover {
            border-color: #3b82f6; /* Blue-500 on hover */
        }

        .die.rolling {
            animation: roll 0.5s infinite linear;
        }

        @keyframes roll {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* CSS for the spinner container (now holds canvas and central pointer) */
        .spinner-container {
            position: relative;
            width: 250px; /* Larger size for the wheel */
            height: 250px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            background-color: transparent; /* Background for visibility */
        }

        .spinner-canvas {
            position: absolute;
            top: 0;
            left: 0;
            /* The canvas itself no longer transitions for spinning */
        }

        /* New central spinning pointer */
        .central-spinner-pointer {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 20px solid #dc2626; /* Red pointer, pointing down */
            top: 50%; /* Position in the middle vertically */
            left: 50%; /* Position in the middle horizontally */
            transform: translate(-50%, -100%); /* Adjust to point from center-top */
            transform-origin: 50% 100%; /* Rotate around its base */
            transition: transform 3s ease-out; /* Smooth spin transition */
            z-index: 10; /* Ensure pointer is on top */
        }

        /* Optional: Styles for the result text overlay */
        .spinner-result-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 1.2rem; /* Adjusted for larger wheel */
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 8px;
            z-index: 11; /* Ensure text is above pointer */
            word-break: break-word; /* Allow text to wrap */
            max-width: 80%; /* Limit width of text overlay */
            text-align: center;
        }

        /* Transition classes for cards */
        .card-transition {
            transition: opacity 0.5s ease-in-out, max-height 0.5s ease-in-out;
            overflow: hidden;
        }
        .card-hidden {
            opacity: 0;
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
            margin-bottom: 0;
            visibility: hidden; /* Prevent interaction when hidden */
        }
        .card-visible {
            opacity: 1;
            max-height: 1000px; /* Large enough to cover content */
            visibility: visible; /* Make interactable when visible */
        }

        /* Splash Screen Styles */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Dark overlay */
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            z-index: 2000; /* Above all other content */
            padding: 20px;
            box-sizing: border-box;
            word-break: break-word;
        }

        .splash-screen.show {
            opacity: 1;
            visibility: visible;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative; /* Needed for absolute positioning of arrows */
        }

        /* Arrow button styling within modal */
        .modal-arrow-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: #e2e8f0; /* Gray-200 */
            color: #2d3748; /* Gray-800 */
            font-weight: bold;
            padding: 0.5rem 0.8rem;
            border-radius: 9999px; /* Full rounded */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            cursor: pointer;
            font-size: 1.25rem; /* Larger arrow text */
            line-height: 1; /* Align arrow vertically */
        }
        .modal-arrow-button:hover:not(:disabled) {
            background-color: #cbd5e0; /* Gray-300 */
            transform: translateY(-50%) scale(1.05);
        }
        .modal-arrow-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #prevCoinModalBtn, #prevDieModalBtn, #prevSpinnerModalBtn {
            left: 1rem;
        }
        #nextCoinModalBtn, #nextDieModalBtn, #nextSpinnerModalBtn {
            right: 1rem;
        }

        /* Saved Slot Button Style */
        .saved-slot-btn {
            background-color: #fcd34d; /* Yellow-300 for coin, adjusted for die */
            color: #3b444b; /* Dark text */
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            cursor: pointer;
            width: 100%; /* Make it fill the container */
            text-align: center;
            border: none;
            position: relative; /* For delete button positioning */
        }
        .saved-slot-btn:hover {
            background-color: #fbbf24; /* Yellow-400 for coin, adjusted for die */
            transform: translateY(-1px);
        }
        .saved-die-slot-btn {
            background-color: #93c5fd; /* Blue-300 */
            color: #1e3a8a; /* Dark blue text */
        }
        .saved-die-slot-btn:hover {
            background-color: #60a5fa; /* Blue-400 */
        }
        .saved-spinner-slot-btn {
            background-color: #f0abfc; /* Fuchsia-300 */
            color: #831843; /* Dark fuchsia text */
        }
        .saved-spinner-slot-btn:hover {
            background-color: #e879f9; /* Fuchsia-400 */
        }

        .delete-saved-option-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #ef4444; /* Red-500 */
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 0.75rem;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s;
        }
        .delete-saved-option-btn:hover {
            background-color: #dc2626; /* Red-600 */
        }

        /* Style for saved options when in delete mode */
        .saved-slot-btn.delete-mode {
            border-color: #ef4444; /* Red border */
            box-shadow: 0 0 0 2px #ef4444; /* Red glow */
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4 sm:p-6 md:p-8">
    <div class="max-w-4xl w-full bg-white rounded-2xl shadow-xl p-6 sm:p-8 md:p-10 lg:p-12 space-y-8">
        <!-- App Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl sm:text-5xl font-extrabold text-gray-800 tracking-tight mb-2">Decido</h1>
            <p class="text-lg text-gray-600">When you can’t decide, let Decido decide for you.</p>
        </header>

        <!-- Main Card Container -->
        <div id="mainCardContainer">
            <!-- Initial Decision Selection Card -->
            <section id="decisionSelectionCard" class="card-transition card-visible bg-gradient-to-br from-purple-500 to-indigo-600 p-6 sm:p-8 rounded-xl shadow-lg text-white text-center space-y-6">
                <h2 class="text-3xl sm:text-4xl font-bold mb-4">What's your dilemma?</h2>
                <div class="flex flex-col sm:flex-row justify-center gap-4">
                    <button id="showCoinCountBtn"
                            class="bg-white text-purple-700 hover:bg-purple-100 font-bold py-4 px-8 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   text-xl w-full sm:w-auto">
                        Flip a Coin
                    </button>
                    <button id="showDieCountBtn"
                            class="bg-white text-indigo-700 hover:bg-indigo-100 font-bold py-4 px-8 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   text-xl w-full sm:w-auto">
                        Roll a Die
                    </button>
                    <button id="showSpinnerCountBtn"
                            class="bg-white text-fuchsia-700 hover:bg-fuchsia-100 font-bold py-4 px-8 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   text-xl w-full sm:w-auto">
                        Spin a Spinner
                    </button>
                </div>
                <div class="flex justify-center mt-6">
                    <button id="viewSavedOptionsBtn"
                            class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                        View Saved Options
                    </button>
                </div>
            </section>

            <!-- Count Selection Card -->
            <section id="countSelectionCard" class="card-transition card-hidden" style="display: none;">
                <div class="bg-gray-100 p-6 sm:p-8 rounded-xl shadow-md border border-gray-200">
                    <h2 id="countSelectionTitle" class="text-3xl font-bold text-gray-800 mb-6 text-center">How many?</h2>
                    <div class="flex justify-center gap-4 mb-6">
                        <!-- Dynamically generated count buttons -->
                    </div>
                    <div class="flex justify-center">
                        <button id="backToMainBtn"
                                class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                       transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                       w-full sm:w-auto text-lg">
                            Back
                        </button>
                    </div>
                </div>
            </section>

            <!-- Coin Flip Section -->
            <section id="coinCard" class="card-transition card-hidden" style="display: none;">
                <div class="bg-yellow-50 p-6 sm:p-8 rounded-xl shadow-md border border-yellow-200">
                    <h2 id="coinCardTitle" class="text-3xl font-bold text-yellow-800 mb-6 text-center">Flip a Coin</h2>

                    <!-- Coin Display and Result -->
                    <div id="coinResultDisplay" class="decision-display mb-8 text-yellow-700">
                        <!-- Coins will be dynamically added here -->
                    </div>

                    <!-- Coin Actions -->
                    <div class="flex flex-col sm:flex-row justify-center gap-4">
                        <button id="flipCoinBtn"
                                class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Flip
                        </button>
                    </div>
                    <div class="flex flex-col sm:flex-row justify-center gap-4 mt-4">
                        <button id="customizeCoinBtn"
                                class="bg-yellow-300 hover:bg-yellow-400 text-yellow-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Customize
                        </button>
                        <button id="changeCoinCountBtn"
                                class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Change Count
                        </button>
                        <button id="returnToMenuFromCoin"
                                class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Return to Menu
                        </button>
                    </div>
                </div>
            </section>

            <!-- Die Roll Section -->
            <section id="dieCard" class="card-transition card-hidden" style="display: none;">
                <div class="bg-blue-50 p-6 sm:p-8 rounded-xl shadow-md border border-blue-200">
                    <h2 id="dieCardTitle" class="text-3xl font-bold text-blue-800 mb-6 text-center">Roll a Die</h2>

                    <!-- Die Display and Result -->
                    <div id="dieResultDisplay" class="decision-display mb-8 text-blue-700">
                        <!-- Dice will be dynamically added here -->
                    </div>

                    <!-- Die Actions -->
                    <div class="flex flex-col sm:flex-row justify-center gap-4">
                        <button id="rollDieBtn"
                                class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Roll
                        </button>
                    </div>
                    <div class="flex flex-col sm:flex-row justify-center gap-4 mt-4">
                        <button id="customizeDieBtn"
                                class="bg-blue-300 hover:bg-blue-400 text-blue-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Customize
                        </button>
                        <button id="changeDieCountBtn"
                                class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Change Count
                        </button>
                        <button id="returnToMenuFromDie"
                                class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Return to Menu
                        </button>
                    </div>
                </div>
            </section>

            <!-- Spinner Section -->
            <section id="spinnerCard" class="card-transition card-hidden" style="display: none;">
                <div class="bg-fuchsia-50 p-6 sm:p-8 rounded-xl shadow-md border border-fuchsia-200">
                    <h2 id="spinnerCardTitle" class="text-3xl font-bold text-fuchsia-800 mb-6 text-center">Spin a Spinner</h2>

                    <!-- Spinner Display and Result -->
                    <div id="spinnerResultDisplay" class="decision-display mb-8 text-fuchsia-700">
                        <!-- Single spinner will be dynamically added here -->
                    </div>

                    <!-- Spinner Actions -->
                    <div class="flex flex-col sm:flex-row justify-center gap-4">
                        <button id="spinSpinnerBtn"
                                class="bg-fuchsia-500 hover:bg-fuchsia-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Spin
                        </button>
                    </div>
                    <div class="flex flex-col sm:flex-row justify-center gap-4 mt-4">
                        <button id="customizeSpinnerBtn"
                                class="bg-fuchsia-300 hover:bg-fuchsia-400 text-fuchsia-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Customize
                        </button>
                        <button id="changeSpinnerCountBtn"
                                class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-00 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Change Parts
                        </button>
                        <button id="returnToMenuFromSpinner"
                                class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Return to Menu
                        </button>
                    </div>
                </div>
            </section>
        </div>
    </div>

    <!-- Message Box for Alerts -->
    <div id="messageBox" class="message-box"></div>

    <!-- Splash Screen for Result -->
    <div id="resultSplashScreen" class="splash-screen"></div>

    <!-- Coin Edit Modal -->
    <div id="coinEditModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="coinEditModalTitle" class="text-2xl font-bold text-gray-800 mb-4">Edit Coin Options</h3>
            <div class="space-y-4 mb-6">
                <div>
                    <label for="modalCoinOption1" class="block text-gray-700 text-sm font-semibold mb-2">Option 1 (Heads):</label>
                    <input type="text" id="modalCoinOption1"
                           class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500">
                </div>
                <div>
                    <label for="modalCoinOption2" class="block text-gray-700 text-sm font-semibold mb-2">Option 2 (Tails):</label>
                    <input type="text" id="modalCoinOption2"
                           class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500">
                </div>
            </div>
            <!-- Saved Coin Options within Modal -->
            <div class="bg-yellow-100 p-4 rounded-lg mt-6 shadow-inner">
                <h4 class="text-xl font-bold text-yellow-800 mb-4 text-center">Saved Coin Options</h4>
                <button id="saveCurrentCoinOptionsBtn"
                        class="bg-yellow-400 hover:bg-yellow-500 text-white text-sm font-bold py-2 px-4 rounded-lg shadow-md
                               transition duration-200 mb-4">
                    Save Current Coin
                </button>
                <button id="deleteSavedCoinOptionsBtn"
                        class="bg-red-400 hover:bg-red-500 text-white text-sm font-bold py-2 px-4 rounded-lg shadow-md
                               transition duration-200 mb-4">
                    Delete Saved
                </button>
                <div id="coinSaveSlotsContainerInModal" class="space-y-3">
                    <!-- Saved slots will be dynamically generated here -->
                </div>
            </div>
            <div class="flex justify-between items-center gap-4 mt-6 relative">
                <button id="prevCoinModalBtn"
                        class="modal-arrow-button" style="left: 1rem;">
                    &larr;
                </button>
                <div class="flex justify-center gap-4 flex-grow"> <!-- Added flex-grow to center buttons -->
                    <button id="saveCoinOptionsBtn"
                            class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-5 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                        Save
                    </button>
                    <button id="cancelCoinOptionsBtn"
                            class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                        Cancel
                    </button>
                </div>
                <button id="nextCoinModalBtn"
                        class="modal-arrow-button" style="right: 1rem;">
                    &rarr;
                </button>
            </div>
        </div>
    </div>

    <!-- Die Edit Modal -->
    <div id="dieEditModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="dieEditModalTitle" class="text-2xl font-bold text-gray-800 mb-4">Edit Die Options</h3>
            <div class="grid grid-cols-2 gap-4 mb-6">
                <!-- Input fields for 6 die faces -->
                <div>
                    <label for="modalDieOption1" class="block text-gray-700 text-sm font-semibold mb-1">Face 1:</label>
                    <input type="text" id="modalDieOption1"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="modalDieOption2" class="block text-gray-700 text-sm font-semibold mb-1">Face 2:</label>
                    <input type="text" id="modalDieOption2"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="modalDieOption3" class="block text-gray-700 text-sm font-semibold mb-1">Face 3:</label>
                    <input type="text" id="modalDieOption3"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="modalDieOption4" class="block text-gray-700 text-sm font-semibold mb-1">Face 4:</label>
                    <input type="text" id="modalDieOption4"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="modalDieOption5" class="block text-gray-700 text-sm font-semibold mb-1">Face 5:</label>
                    <input type="text" id="modalDieOption5"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="modalDieOption6" class="block text-gray-700 text-sm font-semibold mb-1">Face 6:</label>
                    <input type="text" id="modalDieOption6"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
            <!-- Saved Die Options within Modal -->
            <div class="bg-blue-100 p-4 rounded-lg mt-6 shadow-inner">
                <h4 class="text-xl font-bold text-blue-800 mb-4 text-center">Saved Die Options</h4>
                <button id="saveCurrentDieOptionsBtn"
                        class="bg-blue-400 hover:bg-blue-500 text-white text-sm font-bold py-2 px-4 rounded-lg shadow-md
                               transition duration-200 mb-4">
                    Save Current Die
                </button>
                <button id="deleteSavedDieOptionsBtn"
                        class="bg-red-400 hover:bg-red-500 text-white text-sm font-bold py-2 px-4 rounded-lg shadow-md
                               transition duration-200 mb-4">
                    Delete Saved
                </button>
                <div id="dieSaveSlotsContainerInModal" class="space-y-3">
                    <!-- Saved slots will be dynamically generated here -->
                </div>
            </div>
            <div class="flex justify-between items-center gap-4 mt-6 relative">
                <button id="prevDieModalBtn"
                        class="modal-arrow-button" style="left: 1rem;">
                    &larr;
                </button>
                <div class="flex justify-center gap-4 flex-grow"> <!-- Added flex-grow to center buttons -->
                    <button id="saveDieOptionsBtn"
                            class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-5 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                        Save
                    </button>
                    <button id="cancelDieOptionsBtn"
                            class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                        Cancel
                    </button>
                </div>
                <button id="nextDieModalBtn"
                        class="modal-arrow-button" style="right: 1rem;">
                    &rarr;
                </button>
            </div>
        </div>
    </div>

    <!-- Spinner Edit Modal -->
    <div id="spinnerEditModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="spinnerEditModalTitle" class="text-2xl font-bold text-gray-800 mb-4">Edit Spinner Options</h3>
            <div id="modalSpinnerOptionInputs" class="space-y-4 mb-6">
                <!-- Dynamically generated input fields for spinner parts -->
            </div>
            <!-- Saved Spinner Options within Modal -->
            <div class="bg-fuchsia-100 p-4 rounded-lg mt-6 shadow-inner">
                <h4 class="text-xl font-bold text-fuchsia-800 mb-4 text-center">Saved Spinner Options</h4>
                <button id="saveCurrentSpinnerOptionsBtn"
                        class="bg-fuchsia-400 hover:bg-fuchsia-500 text-white text-sm font-bold py-2 px-4 rounded-lg shadow-md
                               transition duration-200 mb-4">
                    Save Current Spinner
                </button>
                <button id="deleteSavedSpinnerOptionsBtn"
                        class="bg-red-400 hover:bg-red-500 text-white text-sm font-bold py-2 px-4 rounded-lg shadow-md
                               transition duration-200 mb-4">
                    Delete Saved
                </button>
                <div id="spinnerSaveSlotsContainerInModal" class="space-y-3">
                    <!-- Saved slots will be dynamically generated here -->
                </div>
            </div>
            <div class="flex justify-between items-center gap-4 mt-6 relative">
                <button id="prevSpinnerModalBtn"
                        class="modal-arrow-button" style="left: 1rem;">
                    &larr;
                </button>
                <div class="flex justify-center gap-4 flex-grow"> <!-- Added flex-grow to center buttons -->
                    <button id="saveSpinnerOptionsBtn"
                            class="bg-fuchsia-500 hover:bg-fuchsia-600 text-white font-bold py-2 px-5 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                        Save
                    </button>
                    <button id="cancelSpinnerOptionsBtn"
                            class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                        Cancel
                    </button>
                </div>
                <button id="nextSpinnerModalBtn"
                        class="modal-arrow-button" style="right: 1rem;">
                    &rarr;
                </button>
            </div>
        </div>
    </div>

    <!-- Saved Options Central Modal -->
    <div id="savedOptionsModal" class="modal-overlay">
        <div class="modal-content max-w-lg">
            <h3 class="text-2xl font-bold text-gray-800 mb-6">Your Saved Options</h3>

            <div class="space-y-6">
                <!-- Saved Coins Section -->
                <div class="bg-yellow-100 p-4 rounded-lg shadow-inner">
                    <h4 class="text-xl font-bold text-yellow-800 mb-3">Saved Coins</h4>
                    <div id="savedCoinsList" class="space-y-2">
                        <p class="text-sm text-gray-600">No saved coins yet.</p>
                    </div>
                </div>

                <!-- Saved Dice Section -->
                <div class="bg-blue-100 p-4 rounded-lg shadow-inner">
                    <h4 class="text-xl font-bold text-blue-800 mb-3">Saved Dice</h4>
                    <div id="savedDiceList" class="space-y-2">
                        <p class="text-sm text-gray-600">No saved dice yet.</p>
                    </div>
                </div>

                <!-- Saved Spinners Section -->
                <div class="bg-fuchsia-100 p-4 rounded-lg shadow-inner">
                    <h4 class="text-xl font-bold text-fuchsia-800 mb-3">Saved Spinners</h4>
                    <div id="savedSpinnersList" class="space-y-2">
                        <p class="text-sm text-gray-600">No saved spinners yet.</p>
                    </div>
                </div>
            </div>

            <div class="flex justify-center mt-6">
                <button id="closeSavedOptionsModalBtn"
                        class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg shadow-md
                               transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Coin Action Choice Modal -->
    <div id="coinActionChoiceModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="coinActionChoiceTitle" class="text-2xl font-bold text-gray-800 mb-4">What do you want to do with this coin?</h3>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                <button id="flipSavedCoinBtn"
                        class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                               transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                               w-full sm:w-auto text-lg">
                    Flip Coin
                </button>
                <button id="spinSavedCoinAsSpinnerBtn"
                        class="bg-fuchsia-500 hover:bg-fuchsia-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                               transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                               w-full sm:w-auto text-lg">
                    Spin as 2-Part Spinner
                </button>
            </div>
            <button id="cancelCoinActionBtn"
                    class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg shadow-md
                           transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95 mt-4">
                Cancel
            </button>
        </div>
    </div>

    <!-- Die Action Choice Modal -->
    <div id="dieActionChoiceModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="dieActionChoiceTitle" class="text-2xl font-bold text-gray-800 mb-4">What do you want to do with this die?</h3>
            <div class="flex flex-col sm:flex-row justify-center gap-4 mt-6">
                <button id="rollSavedDieBtn"
                        class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                               transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                               w-full sm:w-auto text-lg">
                    Roll Die
                </button>
                <button id="spinSavedDieAsSpinnerBtn"
                        class="bg-fuchsia-500 hover:bg-fuchsia-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                               transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                               w-full sm:w-auto text-lg">
                    Spin as 6-Part Spinner
                </button>
            </div>
            <button id="cancelDieActionBtn"
                    class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg shadow-md
                           transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95 mt-4">
                Cancel
            </button>
        </div>
    </div>

    <script>
        // Utility function to show a custom message box instead of alert()
        function showMessage(message, type = 'success', duration = 3000) {
            const msgBox = document.getElementById('messageBox');
            msgBox.textContent = message;
            msgBox.className = 'message-box show'; // Reset classes and show
            if (type === 'error') {
                msgBox.style.backgroundColor = '#f44336'; // Red for error
            } else if (type === 'info') {
                msgBox.style.backgroundColor = '#2196F3'; // Blue for info
            } else {
                msgBox.style.backgroundColor = '#4CAF50'; // Green for success
            }

            setTimeout(() => {
                msgBox.classList.remove('show');
            }, duration);
        }

        // --- Splash Screen Logic ---
        const resultSplashScreen = document.getElementById('resultSplashScreen');

        function showResultSplashScreen(result, callback) {
            resultSplashScreen.textContent = result;
            resultSplashScreen.classList.add('show');

            setTimeout(() => {
                resultSplashScreen.classList.remove('show');
                setTimeout(() => { // Small delay to ensure fade-out completes
                    if (callback) callback();
                }, 500); // Match splash screen transition duration
            }, 1500); // Display result for 1.5 seconds
        }


        // --- Card Visibility Management ---
        const decisionSelectionCard = document.getElementById('decisionSelectionCard');
        const countSelectionCard = document.getElementById('countSelectionCard');
        const coinCard = document.getElementById('coinCard');
        const dieCard = document.getElementById('dieCard');
        const spinnerCard = document.getElementById('spinnerCard');

        const showCoinCountBtn = document.getElementById('showCoinCountBtn');
        const showDieCountBtn = document.getElementById('showDieCountBtn');
        const showSpinnerCountBtn = document.getElementById('showSpinnerCountBtn');
        const backToMainBtn = document.getElementById('backToMainBtn');
        const countSelectionTitle = document.getElementById('countSelectionTitle');
        const countButtonsContainer = countSelectionCard.querySelector('.flex.justify-center.gap-4.mb-6');

        const viewSavedOptionsBtn = document.getElementById('viewSavedOptionsBtn');
        const savedOptionsModal = document.getElementById('savedOptionsModal');
        const closeSavedOptionsModalBtn = document.getElementById('closeSavedOptionsModalBtn');
        const savedCoinsList = document.getElementById('savedCoinsList');
        const savedDiceList = document.getElementById('savedDiceList'); // Corrected ID to the one in the central modal
        const savedSpinnersList = document.getElementById('savedSpinnersList');


        const returnToMenuFromCoin = document.getElementById('returnToMenuFromCoin');
        const returnToMenuFromDie = document.getElementById('returnToMenuFromDie');
        const returnToMenuFromSpinner = document.getElementById('returnToMenuFromSpinner');

        const changeCoinCountBtn = document.getElementById('changeCoinCountBtn');
        const changeDieCountBtn = document.getElementById('changeDieCountBtn');
        const changeSpinnerCountBtn = document.getElementById('changeSpinnerCountBtn');

        const coinCardTitle = document.getElementById('coinCardTitle');
        const dieCardTitle = document.getElementById('dieCardTitle');
        const spinnerCardTitle = document.getElementById('spinnerCardTitle');


        let currentDecisionType = ''; // 'coin', 'die', or 'spinner'
        let currentCount = 1; // Default count for coins/dice/spinner parts


        function showCard(cardToShow, type = '') {
            // First, process all cards to be hidden
            [decisionSelectionCard, countSelectionCard, coinCard, dieCard, spinnerCard].forEach(card => {
                if (card !== cardToShow) {
                    card.classList.remove('card-visible');
                    card.classList.add('card-hidden');
                    // After the CSS transition completes, set display to 'none'
                    setTimeout(() => {
                        if (card.classList.contains('card-hidden')) { // Only apply if still hidden
                            card.style.display = 'none';
                        }
                    }, 500); // Must match CSS transition duration
                }
            });

            // Then, immediately prepare and show the target card
            cardToShow.style.display = 'block'; // Ensure it's in the flow
            // Small delay to ensure browser registers 'display: block' before animating max-height
            setTimeout(() => {
                cardToShow.classList.remove('card-hidden');
                cardToShow.classList.add('card-visible');
            }, 10);

            if (cardToShow === countSelectionCard) {
                currentDecisionType = type;
                let countOptionsHtml = '';
                if (type === 'coin' || type === 'die') {
                    countSelectionTitle.textContent = `How many ${type === 'coin' ? 'coins' : 'dice'}?`;
                    [1, 2, 3].forEach(c => {
                        countOptionsHtml += `<button class="count-btn bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95 text-lg" data-count="${c}">${c}</button>`;
                    });
                } else if (type === 'spinner') {
                    countSelectionTitle.textContent = `How many parts of the pie chart?`;
                    [2, 3, 4, 5, 6, 8].forEach(c => {
                        countOptionsHtml += `<button class="count-btn bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95 text-lg" data-count="${c}">${c}</button>`;
                    });
                }
                countButtonsContainer.innerHTML = countOptionsHtml;
                // Re-attach event listeners for newly created buttons
                countButtonsContainer.querySelectorAll('.count-btn').forEach(button => {
                    button.addEventListener('click', handleCountButtonClick);
                });
            } else if (cardToShow === coinCard) {
                // Initialize coinOptions for the new count if needed
                if (coinOptions.length !== currentCount) {
                    coinOptions = Array.from({length: currentCount}, () => ({heads: "Heads", tails: "Tails"}));
                }
                updateCoinDisplay(); // Ensure display and title are updated when coinCard is shown
                loadSavedCoinSlots(); // Load saved slots on coin card display
            } else if (cardToShow === dieCard) {
                // Initialize dieOptions for the new count if needed
                if (dieOptions.length !== currentCount) {
                    dieOptions = Array.from({length: currentCount}, () => ({faces: ["1", "2", "3", "4", "5", "6"]}));
                }
                updateDieDisplay(); // Ensure display and title are updated when dieCard is shown
                loadSavedDieSlots(); // Load saved slots on die card display
            } else if (cardToShow === spinnerCard) {
                // Initialize spinnerOptions for the new count if needed
                if (spinnerOptions.length !== currentCount) {
                    spinnerOptions = Array.from({length: currentCount}, (_, i) => `Option ${i + 1}`);
                }
                updateSpinnerDisplay(); // Ensure display and title are updated when spinnerCard is shown
                loadSavedSpinnerSlots(); // Load saved slots on spinner card display
            }
        }

        // Central handler for count buttons to avoid re-attaching multiple times
        function handleCountButtonClick(event) {
            currentCount = parseInt(event.target.dataset.count, 10);
            if (currentDecisionType === 'coin') {
                showCard(coinCard);
            } else if (currentDecisionType === 'die') {
                showCard(dieCard);
            } else if (currentDecisionType === 'spinner') {
                showCard(spinnerCard);
            }
        }


        // Event listeners for initial decision selection
        showCoinCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'coin'));
        showDieCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'die'));
        showSpinnerCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'spinner'));
        backToMainBtn.addEventListener('click', () => showCard(decisionSelectionCard));

        // Event listeners for post-decision actions
        returnToMenuFromCoin.addEventListener('click', () => showCard(decisionSelectionCard));
        returnToMenuFromDie.addEventListener('click', () => showCard(decisionSelectionCard));
        returnToMenuFromSpinner.addEventListener('click', () => showCard(decisionSelectionCard));

        changeCoinCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'coin'));
        changeDieCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'die'));
        changeSpinnerCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'spinner'));

        // --- Saved Options Central Modal Logic ---
        viewSavedOptionsBtn.addEventListener('click', () => {
            loadSavedCoinSlots();
            loadSavedDieSlots();
            loadSavedSpinnerSlots();
            renderSavedCoinsList();
            renderSavedDiceList();
            renderSavedSpinnersList();
            savedOptionsModal.classList.add('show');
        });

        closeSavedOptionsModalBtn.addEventListener('click', () => {
            savedOptionsModal.classList.remove('show');
        });

        savedOptionsModal.addEventListener('click', (event) => {
            if (event.target === savedOptionsModal) {
                closeSavedOptionsModal();
            }
        });

        function closeSavedOptionsModal() {
            savedOptionsModal.classList.remove('show');
        }


        // --- Coin Flip Logic ---
        const flipCoinBtn = document.getElementById('flipCoinBtn');
        const customizeCoinBtn = document.getElementById('customizeCoinBtn');
        const coinResultDisplay = document.getElementById('coinResultDisplay');
        
        let coinOptions = [{heads: "Heads", tails: "Tails"}]; // Default options, now an array of objects

        // Function to update the visual display of coins
        function updateCoinDisplay(results = []) {
            coinResultDisplay.innerHTML = ''; // Clear previous coins
            for (let i = 0; i < currentCount; i++) {
                const coinDiv = document.createElement('div');
                coinDiv.classList.add('coin');
                coinDiv.textContent = results[i] || '?'; // Show result or '?'
                coinDiv.dataset.index = i; // Store index for animation
                coinDiv.addEventListener('click', () => openCoinEditModal(i)); // Add click listener
                // Removed selected class logic
                coinResultDisplay.appendChild(coinDiv);
            }
            // Update the title based on currentCount
            coinCardTitle.textContent = currentCount > 1 ? 'Flip Coins' : 'Flip a Coin';
            // Removed updateCoinNavButtons()
        }

        // Removed updateCoinNavButtons function

        // Event listener for Flip Coin button
        flipCoinBtn.addEventListener('click', () => {
            const coinElements = coinResultDisplay.querySelectorAll('.coin');
            // coinPostDecisionActions.classList.add('hidden'); // Removed: no longer hiding this div
            flipCoinBtn.disabled = true; // Disable button during animation
            customizeCoinBtn.disabled = true; // Disable customize button during flip
            changeCoinCountBtn.disabled = true; // Disable change count button
            returnToMenuFromCoin.disabled = true; // Disable return to menu button

            const results = []; // Store results for splash screen
            coinElements.forEach((coinEl, index) => {
                const currentCoinOptions = coinOptions[index]; // Get options for this specific coin
                const chosenOption = Math.random() < 0.5 ? currentCoinOptions.heads : currentCoinOptions.tails;
                results.push(chosenOption);

                coinEl.textContent = '?'; // Reset text
                coinEl.classList.add('flipping');

                setTimeout(() => {
                    coinEl.classList.remove('flipping');
                    coinEl.textContent = chosenOption;
                    if (index === coinElements.length - 1) { // Only re-enable after last coin finishes
                        flipCoinBtn.disabled = false;
                        customizeCoinBtn.disabled = false; // Re-enable customize button
                        changeCoinCountBtn.disabled = false; // Re-enable change count button
                        returnToMenuFromCoin.disabled = false; // Re-enable return to menu button
                        // Show splash screen with combined results
                        showResultSplashScreen(results.join(', '), () => {
                            // coinPostDecisionActions.classList.remove('hidden'); // Removed: no longer hiding this div
                        });
                    }
                }, 1000 + (index * 100)); // Stagger animations slightly
            });
        });


        // --- Coin Edit Modal Logic ---
        const coinEditModal = document.getElementById('coinEditModal');
        const coinEditModalTitle = document.getElementById('coinEditModalTitle');
        const modalCoinOption1Input = document.getElementById('modalCoinOption1');
        const modalCoinOption2Input = document.getElementById('modalCoinOption2');
        const saveCoinOptionsBtn = document.getElementById('saveCoinOptionsBtn');
        const cancelCoinOptionsBtn = document.getElementById('cancelCoinOptionsBtn');
        const prevCoinModalBtn = document.getElementById('prevCoinModalBtn');
        const nextCoinModalBtn = document.getElementById('nextCoinModalBtn');
        const saveCurrentCoinOptionsBtn = document.getElementById('saveCurrentCoinOptionsBtn'); // New
        const coinSaveSlotsContainerInModal = document.getElementById('coinSaveSlotsContainerInModal'); // New

        let editingCoinIndex = -1; // To keep track of which coin is being edited
        let isDeletingSavedCoin = false; // New state for delete mode

        function openCoinEditModal(index) {
            editingCoinIndex = index;
            modalCoinOption1Input.value = coinOptions[index].heads;
            modalCoinOption2Input.value = coinOptions[index].tails;
            coinEditModalTitle.textContent = `Edit Options for Coin ${index + 1}`; // Update modal title
            
            // Manage navigation button visibility within the modal
            prevCoinModalBtn.style.display = (editingCoinIndex === 0) ? 'none' : 'block';
            nextCoinModalBtn.style.display = (editingCoinIndex === currentCount - 1) ? 'none' : 'block';

            renderCoinSaveSlotsInModal(); // Render saved slots inside the modal
            coinEditModal.classList.add('show');
        }

        function closeCoinEditModal() {
            coinEditModal.classList.remove('show');
            editingCoinIndex = -1;
            isDeletingSavedCoin = false; // Reset delete mode on close
        }

        saveCoinOptionsBtn.addEventListener('click', () => {
            if (editingCoinIndex !== -1) {
                const opt1 = modalCoinOption1Input.value.trim();
                const opt2 = modalCoinOption2Input.value.trim();
                if (opt1 && opt2) {
                    coinOptions[editingCoinIndex].heads = opt1;
                    coinOptions[editingCoinIndex].tails = opt2;
                    showMessage(`Coin ${editingCoinIndex + 1} options saved!`, "info");
                } else {
                    showMessage("Please provide both options for the coin.", "error");
                    return; // Don't close modal if validation fails
                }
            }
            closeCoinEditModal();
            updateCoinDisplay(); // Redraw coins with potentially updated text
        });

        cancelCoinOptionsBtn.addEventListener('click', closeCoinEditModal);

        // Event listener for the main "Customize" button
        customizeCoinBtn.addEventListener('click', () => {
            if (currentCount > 0) {
                openCoinEditModal(0); // Open modal for the first coin
            } else {
                showMessage("Please select a count of coins first.", "info");
            }
        });

        // Navigation for coins *within the modal*
        prevCoinModalBtn.addEventListener('click', () => {
            if (editingCoinIndex > 0) {
                // Save current edits before navigating
                if (modalCoinOption1Input.value.trim() && modalCoinOption2Input.value.trim()) {
                    coinOptions[editingCoinIndex].heads = modalCoinOption1Input.value.trim();
                    coinOptions[editingCoinIndex].tails = modalCoinOption2Input.value.trim();
                } else {
                    showMessage("Please save or cancel current coin edits before navigating.", "error");
                    return;
                }
                openCoinEditModal(editingCoinIndex - 1);
            }
        });

        nextCoinModalBtn.addEventListener('click', () => {
            if (editingCoinIndex < currentCount - 1) {
                // Save current edits before navigating
                if (modalCoinOption1Input.value.trim() && modalCoinOption2Input.value.trim()) {
                    coinOptions[editingCoinIndex].heads = modalCoinOption1Input.value.trim();
                    coinOptions[editingCoinIndex].tails = modalCoinOption2Input.value.trim();
                } else {
                    showMessage("Please save or cancel current coin edits before navigating.", "error");
                    return;
                }
                openCoinEditModal(editingCoinIndex + 1);
            }
        });

        // Close modal on outside click
        coinEditModal.addEventListener('click', (event) => {
            if (event.target === coinEditModal) {
                closeCoinEditModal();
            }
        });


        // --- Saved Coin Slots Logic ---
        let savedCoinSlots = []; // Array to store saved options

        // Function to load saved slots from localStorage
        function loadSavedCoinSlots() {
            const savedData = localStorage.getItem('decidoCoinSlots');
            if (savedData) {
                savedCoinSlots = JSON.parse(savedData);
            } else {
                // Initialize with empty slots if no data found
                savedCoinSlots = []; // Start empty
            }
        }

        // Function to save slots to localStorage
        function saveCoinSlotsToLocalStorage() {
            localStorage.setItem('decidoCoinSlots', JSON.stringify(savedCoinSlots));
        }

        // Function to render the save/recall buttons and their content INSIDE THE MODAL
        function renderCoinSaveSlotsInModal() {
            coinSaveSlotsContainerInModal.innerHTML = ''; // Clear existing
            if (savedCoinSlots.length === 0) {
                coinSaveSlotsContainerInModal.innerHTML = '<p class="text-sm text-gray-600">No saved options yet.</p>';
                document.getElementById('deleteSavedCoinOptionsBtn').disabled = true; // Disable delete button if no slots
            } else {
                document.getElementById('deleteSavedCoinOptionsBtn').disabled = false;
            }

            savedCoinSlots.forEach((slot, index) => {
                const savedCoinButton = document.createElement('button');
                savedCoinButton.classList.add('saved-slot-btn', 'text-sm', 'font-medium', 'text-yellow-700', 'py-2', 'px-3', 'rounded-lg', 'border', 'border-yellow-200', 'w-full', 'mb-2');
                savedCoinButton.textContent = `${slot.name}: ${slot.options.heads} / ${slot.options.tails}`;
                savedCoinButton.dataset.slotIndex = index;

                if (isDeletingSavedCoin) {
                    savedCoinButton.classList.add('delete-mode');
                    savedCoinButton.addEventListener('click', (event) => {
                        const idxToDelete = parseInt(event.target.dataset.slotIndex, 10);
                        if (confirm(`Are you sure you want to delete "${savedCoinSlots[idxToDelete].name}"?`)) {
                            savedCoinSlots.splice(idxToDelete, 1);
                            saveCoinSlotsToLocalStorage();
                            renderCoinSaveSlotsInModal(); // Re-render the list
                            showMessage("Saved coin option deleted!", "info");
                        }
                    });
                } else {
                    savedCoinButton.addEventListener('click', (event) => {
                        const slotIndex = parseInt(event.target.dataset.slotIndex, 10);
                        if (editingCoinIndex !== -1 && savedCoinSlots[slotIndex].options.heads && savedCoinSlots[slotIndex].options.tails) {
                            // Apply recalled options to the currently edited coin
                            coinOptions[editingCoinIndex] = { ...savedCoinSlots[slotIndex].options }; // Load a copy of options
                            // Update modal inputs with recalled options
                            modalCoinOption1Input.value = coinOptions[editingCoinIndex].heads;
                            modalCoinOption2Input.value = coinOptions[editingCoinIndex].tails;
                            showMessage(`Options from "${savedCoinSlots[slotIndex].name}" recalled for Coin ${editingCoinIndex + 1}!`, "info");
                        } else {
                            showMessage("No options saved in this slot to recall.", "error");
                        }
                    });
                }
                coinSaveSlotsContainerInModal.appendChild(savedCoinButton);
            });
            // Update the text of the delete button
            document.getElementById('deleteSavedCoinOptionsBtn').textContent = isDeletingSavedCoin ? 'Cancel Delete' : 'Delete Saved';
        }

        // Function to render the saved coins list in the central saved options modal
        function renderSavedCoinsList() {
            savedCoinsList.innerHTML = '';
            if (savedCoinSlots.length === 0) {
                savedCoinsList.innerHTML = '<p class="text-sm text-gray-600">No saved coins yet.</p>';
            }
            savedCoinSlots.forEach((slot, index) => {
                const slotWrapper = document.createElement('div');
                slotWrapper.classList.add('flex', 'items-center', 'justify-between', 'gap-2', 'w-full', 'mb-2');

                const savedCoinButton = document.createElement('button');
                savedCoinButton.classList.add('saved-slot-btn', 'text-sm', 'font-medium', 'text-yellow-700', 'py-2', 'px-3', 'rounded-lg', 'border', 'border-yellow-200', 'flex-grow');
                savedCoinButton.textContent = `${slot.name}: ${slot.options.heads} / ${slot.options.tails}`;
                savedCoinButton.dataset.slotIndex = index;
                savedCoinButton.addEventListener('click', () => {
                    // Store saved options temporarily for action choice modal
                    tempSavedCoinOptions = { ...slot.options };
                    closeSavedOptionsModal();
                    coinActionChoiceTitle.textContent = `What to do with "${slot.name}"?`;
                    coinActionChoiceModal.classList.add('show');
                });
                slotWrapper.appendChild(savedCoinButton);

                const deleteButton = document.createElement('button');
                deleteButton.classList.add('delete-saved-option-btn');
                deleteButton.textContent = 'x';
                deleteButton.dataset.slotIndex = index;
                deleteButton.addEventListener('click', (event) => {
                    const idxToDelete = parseInt(event.target.dataset.slotIndex, 10);
                    if (confirm(`Are you sure you want to delete "${savedCoinSlots[idxToDelete].name}"?`)) {
                        savedCoinSlots.splice(idxToDelete, 1);
                        saveCoinSlotsToLocalStorage();
                        renderSavedCoinsList(); // Re-render the list
                        showMessage("Saved coin option deleted!", "info");
                    }
                });
                savedCoinsList.appendChild(slotWrapper);
            });
        }


        // Event listener for the "Save Current Coin" button inside the modal
        saveCurrentCoinOptionsBtn.addEventListener('click', () => {
            if (editingCoinIndex !== -1) {
                const opt1 = modalCoinOption1Input.value.trim();
                const opt2 = modalCoinOption2Input.value.trim();
                if (opt1 && opt2) {
                    const saveName = prompt("Name this saved coin option (e.g., 'Yes/No', 'Coffee/Tea'):");
                    if (saveName) {
                        const newSavedOption = {
                            name: saveName.trim(),
                            options: { heads: opt1, tails: opt2 }
                        };
                        // Check if name already exists and replace, or add new
                        const existingIndex = savedCoinSlots.findIndex(slot => slot.name === newSavedOption.name);
                        if (existingIndex !== -1) {
                            savedCoinSlots[existingIndex] = newSavedOption;
                            showMessage(`Updated saved options for "${newSavedOption.name}"!`, "info");
                        } else {
                            savedCoinSlots.push(newSavedOption);
                            showMessage(`Saved options "${newSavedOption.name}"!`, "info");
                        }
                        saveCoinSlotsToLocalStorage();
                        renderCoinSaveSlotsInModal(); // Update display of saved slots
                    } else {
                        showMessage("Save operation cancelled. Please provide a name.", "info");
                    }
                } else {
                    showMessage("Please provide both options for the coin before saving.", "error");
                }
            } else {
                showMessage("No coin is currently being edited.", "error");
            }
        });

        // Event listener for the new "Delete Saved" button in the coin modal
        document.getElementById('deleteSavedCoinOptionsBtn').addEventListener('click', () => {
            isDeletingSavedCoin = !isDeletingSavedCoin; // Toggle delete mode
            renderCoinSaveSlotsInModal(); // Re-render to show/hide highlights
        });


        // --- Coin Action Choice Modal Logic ---
        const coinActionChoiceModal = document.getElementById('coinActionChoiceModal');
        const coinActionChoiceTitle = document.getElementById('coinActionChoiceTitle');
        const flipSavedCoinBtn = document.getElementById('flipSavedCoinBtn');
        const spinSavedCoinAsSpinnerBtn = document.getElementById('spinSavedCoinAsSpinnerBtn');
        const cancelCoinActionBtn = document.getElementById('cancelCoinActionBtn');
        let tempSavedCoinOptions = null; // Temporarily store options from clicked saved slot

        flipSavedCoinBtn.addEventListener('click', () => {
            if (tempSavedCoinOptions) {
                currentCount = 1; // Always flip one coin for this action
                coinOptions = [{ ...tempSavedCoinOptions }]; // Load saved options into the first coin
                closeCoinActionChoiceModal();
                showCard(coinCard);
                // Trigger flip after a short delay to ensure card is rendered
                setTimeout(() => flipCoinBtn.click(), 100);
            }
        });

        spinSavedCoinAsSpinnerBtn.addEventListener('click', () => {
            if (tempSavedCoinOptions) {
                currentCount = 2; // Fixed to 2 parts for coin as spinner
                spinnerOptions = [tempSavedCoinOptions.heads, tempSavedCoinOptions.tails]; // Load saved options as spinner parts
                closeCoinActionChoiceModal();
                showCard(spinnerCard);
                // Trigger spin after a short delay
                setTimeout(() => spinSpinnerBtn.click(), 100);
            }
        });

        cancelCoinActionBtn.addEventListener('click', () => {
            closeCoinActionChoiceModal();
            savedOptionsModal.classList.add('show'); // Return to saved options modal
        });

        coinActionChoiceModal.addEventListener('click', (event) => {
            if (event.target === coinActionChoiceModal) {
                closeCoinActionChoiceModal();
                savedOptionsModal.classList.add('show'); // Return to saved options modal
            }
        });

        function closeCoinActionChoiceModal() {
            coinActionChoiceModal.classList.remove('show');
            tempSavedCoinOptions = null;
        }


        // --- Die Roll Logic ---
        const rollDieBtn = document.getElementById('rollDieBtn');
        const customizeDieBtn = document.getElementById('customizeDieBtn'); // New
        const dieResultDisplay = document.getElementById('dieResultDisplay');
        
        let dieOptions = [{faces: ["1", "2", "3", "4", "5", "6"]}]; // Default options, now an array of objects

        // Function to update the visual display of dice
        function updateDieDisplay(results = []) {
            dieResultDisplay.innerHTML = ''; // Clear previous dice
            for (let i = 0; i < currentCount; i++) {
                const dieDiv = document.createElement('div');
                dieDiv.classList.add('die');
                dieDiv.textContent = results[i] || '?'; // Show result or '?'
                dieDiv.dataset.index = i; // Store index for animation
                dieDiv.addEventListener('click', () => openDieEditModal(i)); // Add click listener
                dieResultDisplay.appendChild(dieDiv);
            }
            // Update the title based on currentCount
            dieCardTitle.textContent = currentCount > 1 ? 'Roll Dice' : 'Roll a Die';
        }

        // Event listener for Roll Die button
        rollDieBtn.addEventListener('click', () => {
            const dieElements = dieResultDisplay.querySelectorAll('.die');
            // diePostDecisionActions.classList.add('hidden'); // Removed: no longer hiding this div
            rollDieBtn.disabled = true; // Disable button during animation
            customizeDieBtn.disabled = true; // Disable customize button during roll
            changeDieCountBtn.disabled = true; // Disable change count button
            returnToMenuFromDie.disabled = true; // Disable return to menu button

            const results = []; // Store results for splash screen
            dieElements.forEach((dieEl, index) => {
                const currentDieFaces = dieOptions[index].faces; // Get faces for this specific die
                const chosenOption = currentDieFaces[Math.floor(Math.random() * currentDieFaces.length)];
                results.push(chosenOption);

                dieEl.textContent = '?'; // Reset text
                dieEl.classList.add('rolling');

                setTimeout(() => {
                    dieEl.classList.remove('rolling');
                    dieEl.textContent = chosenOption;
                    if (index === dieElements.length - 1) { // Only re-enable after last die finishes
                        rollDieBtn.disabled = false;
                        customizeDieBtn.disabled = false; // Re-enable customize button
                        changeDieCountBtn.disabled = false; // Re-enable change count button
                        returnToMenuFromDie.disabled = false; // Re-enable return to menu button
                        // Show splash screen with combined results
                        showResultSplashScreen(results.join(', '), () => {
                            // diePostDecisionActions.classList.remove('hidden'); // Removed: no longer hiding this div
                        });
                    }
                }, 500 + (index * 100)); // Stagger animations slightly
            });
        });

        // --- Die Edit Modal Logic ---
        const dieEditModal = document.getElementById('dieEditModal');
        const dieEditModalTitle = document.getElementById('dieEditModalTitle');
        const modalDieOptionInputs = []; // Array to store references to face input fields
        for (let i = 1; i <= 6; i++) {
            modalDieOptionInputs.push(document.getElementById(`modalDieOption${i}`));
        }
        const saveDieOptionsBtn = document.getElementById('saveDieOptionsBtn');
        const cancelDieOptionsBtn = document.getElementById('cancelDieOptionsBtn');
        const prevDieModalBtn = document.getElementById('prevDieModalBtn');
        const nextDieModalBtn = document.getElementById('nextDieModalBtn');
        const saveCurrentDieOptionsBtn = document.getElementById('saveCurrentDieOptionsBtn'); // New
        const deleteSavedDieOptionsBtn = document.getElementById('deleteSavedDieOptionsBtn'); // New
        const dieSaveSlotsContainerInModal = document.getElementById('dieSaveSlotsContainerInModal'); // New

        let editingDieIndex = -1; // To keep track of which die is being edited
        let isDeletingSavedDie = false; // New state for delete mode

        function openDieEditModal(index) {
            editingDieIndex = index;
            const currentFaces = dieOptions[index].faces;
            modalDieOptionInputs.forEach((input, i) => {
                input.value = currentFaces[i] || (i + 1).toString(); // Populate with current or default
            });
            dieEditModalTitle.textContent = `Edit Options for Die ${index + 1}`; // Update modal title

            // Manage navigation button visibility within the modal
            prevDieModalBtn.style.display = (editingDieIndex === 0) ? 'none' : 'block';
            nextDieModalBtn.style.display = (editingDieIndex === currentCount - 1) ? 'none' : 'block';

            renderDieSaveSlotsInModal(); // Render saved slots inside the modal
            dieEditModal.classList.add('show');
        }

        function closeDieEditModal() {
            dieEditModal.classList.remove('show');
            editingDieIndex = -1;
            isDeletingSavedDie = false; // Reset delete mode on close
        }

        saveDieOptionsBtn.addEventListener('click', () => {
            if (editingDieIndex !== -1) {
                const newFaces = modalDieOptionInputs.map(input => input.value.trim());
                if (newFaces.every(face => face !== '')) { // Ensure all faces have a value
                    dieOptions[editingDieIndex].faces = newFaces;
                    showMessage(`Die ${editingDieIndex + 1} options saved!`, "info");
                } else {
                    showMessage("Please provide a value for all 6 faces of the die.", "error");
                    return; // Don't close modal if validation fails
                }
            }
            closeDieEditModal();
            updateDieDisplay(); // Redraw dice with potentially updated text
        });

        cancelDieOptionsBtn.addEventListener('click', closeDieEditModal);

        // Event listener for the main "Customize" button
        customizeDieBtn.addEventListener('click', () => {
            if (currentCount > 0) {
                openDieEditModal(0); // Open modal for the first die
            } else {
                showMessage("Please select a count of dice first.", "info");
            }
        });

        // Navigation for dice *within the modal*
        prevDieModalBtn.addEventListener('click', () => {
            if (editingDieIndex > 0) {
                // Save current edits before navigating
                const newFaces = modalDieOptionInputs.map(input => input.value.trim());
                if (newFaces.every(face => face !== '')) {
                    dieOptions[editingDieIndex].faces = newFaces;
                } else {
                    showMessage("Please save or cancel current die edits before navigating.", "error");
                    return;
                }
                openDieEditModal(editingDieIndex - 1);
            }
        });

        nextDieModalBtn.addEventListener('click', () => {
            if (editingDieIndex < currentCount - 1) {
                // Save current edits before navigating
                const newFaces = modalDieOptionInputs.map(input => input.value.trim());
                if (newFaces.every(face => face !== '')) {
                    dieOptions[editingDieIndex].faces = newFaces;
                } else {
                    showMessage("Please save or cancel current die edits before navigating.", "error");
                    return;
                }
                openDieEditModal(editingDieIndex + 1);
            }
        });

        // Close modal on outside click
        dieEditModal.addEventListener('click', (event) => {
            if (event.target === dieEditModal) {
                closeDieEditModal();
            }
        });


        // --- Saved Die Slots Logic ---
        let savedDieSlots = []; // Array to store saved die options

        function loadSavedDieSlots() {
            const savedData = localStorage.getItem('decidoDieSlots');
            if (savedData) {
                savedDieSlots = JSON.parse(savedData);
            } else {
                savedDieSlots = [];
            }
        }

        function saveDieSlotsToLocalStorage() {
            localStorage.setItem('decidoDieSlots', JSON.stringify(savedDieSlots));
        }

        function renderDieSaveSlotsInModal() {
            dieSaveSlotsContainerInModal.innerHTML = '';
            if (savedDieSlots.length === 0) {
                dieSaveSlotsContainerInModal.innerHTML = '<p class="text-sm text-gray-600">No saved options yet.</p>';
                document.getElementById('deleteSavedDieOptionsBtn').disabled = true; // Disable delete button if no slots
            } else {
                document.getElementById('deleteSavedDieOptionsBtn').disabled = false;
            }

            savedDieSlots.forEach((slot, index) => {
                const savedDieButton = document.createElement('button');
                savedDieButton.classList.add('saved-slot-btn', 'saved-die-slot-btn', 'text-sm', 'font-medium', 'py-2', 'px-3', 'rounded-lg', 'border', 'border-blue-200', 'w-full', 'mb-2');
                savedDieButton.textContent = `${slot.name}: ${slot.options.faces.join(', ')}`;
                savedDieButton.dataset.slotIndex = index;

                if (isDeletingSavedDie) {
                    savedDieButton.classList.add('delete-mode');
                    savedDieButton.addEventListener('click', (event) => {
                        const idxToDelete = parseInt(event.target.dataset.slotIndex, 10);
                        if (confirm(`Are you sure you want to delete "${savedDieSlots[idxToDelete].name}"?`)) {
                            savedDieSlots.splice(idxToDelete, 1);
                            saveDieSlotsToLocalStorage();
                            renderDieSaveSlotsInModal(); // Re-render the list
                            showMessage("Saved die option deleted!", "info");
                        }
                    });
                } else {
                    savedDieButton.addEventListener('click', (event) => {
                        const slotIndex = parseInt(event.target.dataset.slotIndex, 10);
                        if (editingDieIndex !== -1 && savedDieSlots[slotIndex].options.faces.every(face => face !== '')) {
                            dieOptions[editingDieIndex] = { ...savedDieSlots[slotIndex].options };
                            modalDieOptionInputs.forEach((input, i) => {
                                input.value = dieOptions[editingDieIndex].faces[i];
                            });
                            showMessage(`Options from "${savedDieSlots[slotIndex].name}" recalled for Die ${editingDieIndex + 1}!`, "info");
                        } else {
                            showMessage("No valid options saved in this slot to recall.", "error");
                        }
                    });
                }
                dieSaveSlotsContainerInModal.appendChild(savedDieButton);
            });
            // Update the text of the delete button
            document.getElementById('deleteSavedDieOptionsBtn').textContent = isDeletingSavedDie ? 'Cancel Delete' : 'Delete Saved';
        }

        // Function to render the saved dice list in the central saved options modal
        function renderSavedDiceList() {
            savedDiceList.innerHTML = '';
            if (savedDieSlots.length === 0) {
                savedDiceList.innerHTML = '<p class="text-sm text-gray-600">No saved dice yet.</p>';
            }
            savedDieSlots.forEach((slot, index) => {
                const slotWrapper = document.createElement('div');
                slotWrapper.classList.add('flex', 'items-center', 'justify-between', 'gap-2', 'w-full', 'mb-2');

                const savedDieButton = document.createElement('button');
                savedDieButton.classList.add('saved-slot-btn', 'saved-die-slot-btn', 'text-sm', 'font-medium', 'py-2', 'px-3', 'rounded-lg', 'border', 'border-blue-200', 'flex-grow');
                savedDieButton.textContent = `${slot.name}: ${slot.options.faces.join(', ')}`;
                savedDieButton.dataset.slotIndex = index;
                savedDieButton.addEventListener('click', () => {
                    // Store saved options temporarily for action choice modal
                    tempSavedDieOptions = { ...slot.options };
                    closeSavedOptionsModal();
                    dieActionChoiceTitle.textContent = `What to do with "${slot.name}"?`;
                    dieActionChoiceModal.classList.add('show');
                });
                slotWrapper.appendChild(savedDieButton);

                const deleteButton = document.createElement('button');
                deleteButton.classList.add('delete-saved-option-btn');
                deleteButton.textContent = 'x';
                deleteButton.dataset.slotIndex = index;
                deleteButton.addEventListener('click', (event) => {
                    const idxToDelete = parseInt(event.target.dataset.slotIndex, 10);
                    if (confirm(`Are you sure you want to delete "${savedDieSlots[idxToDelete].name}"?`)) {
                        savedDieSlots.splice(idxToDelete, 1);
                        saveDieSlotsToLocalStorage();
                        renderSavedDiceList(); // Re-render the list
                        showMessage("Saved die option deleted!", "info");
                    }
                });
                savedDiceList.appendChild(slotWrapper);
            });
        }

        // Event listener for the "Save Current Die" button inside the modal
        saveCurrentDieOptionsBtn.addEventListener('click', () => {
            if (editingDieIndex !== -1) {
                const currentFaces = modalDieOptionInputs.map(input => input.value.trim());
                if (currentFaces.every(face => face !== '')) {
                    const saveName = prompt("Name this saved die option (e.g., 'D&D', 'Yes/No/Maybe'):");
                    if (saveName) {
                        const newSavedOption = {
                            name: saveName.trim(),
                            options: { faces: currentFaces }
                        };
                        const existingIndex = savedDieSlots.findIndex(slot => slot.name === newSavedOption.name);
                        if (existingIndex !== -1) {
                            savedDieSlots[existingIndex] = newSavedOption;
                            showMessage(`Updated saved options for "${newSavedOption.name}"!`, "info");
                        } else {
                            savedDieSlots.push(newSavedOption);
                            showMessage(`Saved options "${newSavedOption.name}"!`, "info");
                        }
                        saveDieSlotsToLocalStorage();
                        renderDieSaveSlotsInModal();
                    } else {
                        showMessage("Save operation cancelled. Please provide a name.", "info");
                    }
                } else {
                    showMessage("Please provide a value for all 6 faces of the die before saving.", "error");
                }
            } else {
                showMessage("No die is currently being edited.", "error");
            }
        });

        // Event listener for the new "Delete Saved" button in the die modal
        document.getElementById('deleteSavedDieOptionsBtn').addEventListener('click', () => {
            isDeletingSavedDie = !isDeletingSavedDie; // Toggle delete mode
            renderDieSaveSlotsInModal(); // Re-render to show/hide highlights
        });


        // --- Die Action Choice Modal Logic ---
        const dieActionChoiceModal = document.getElementById('dieActionChoiceModal');
        const dieActionChoiceTitle = document.getElementById('dieActionChoiceTitle');
        const rollSavedDieBtn = document.getElementById('rollSavedDieBtn');
        const spinSavedDieAsSpinnerBtn = document.getElementById('spinSavedDieAsSpinnerBtn');
        const cancelDieActionBtn = document.getElementById('cancelDieActionBtn');
        let tempSavedDieOptions = null; // Temporarily store options from clicked saved slot

        rollSavedDieBtn.addEventListener('click', () => {
            if (tempSavedDieOptions) {
                currentCount = 1; // Always roll one die for this action
                dieOptions = [{ ...tempSavedDieOptions }]; // Load saved options into the first die
                closeDieActionChoiceModal();
                showCard(dieCard);
                // Trigger roll after a short delay to ensure card is rendered
                setTimeout(() => rollDieBtn.click(), 100);
            }
        });

        spinSavedDieAsSpinnerBtn.addEventListener('click', () => {
            if (tempSavedDieOptions) {
                currentCount = 6; // Fixed to 6 parts for die as spinner
                spinnerOptions = [...tempSavedDieOptions.faces]; // Load saved options as spinner parts
                closeDieActionChoiceModal();
                showCard(spinnerCard);
                // Trigger spin after a short delay
                setTimeout(() => spinSpinnerBtn.click(), 100);
            }
        });

        cancelDieActionBtn.addEventListener('click', () => {
            closeDieActionChoiceModal();
            savedOptionsModal.classList.add('show'); // Return to saved options modal
        });

        dieActionChoiceModal.addEventListener('click', (event) => {
            if (event.target === dieActionChoiceModal) {
                closeDieActionChoiceModal();
                savedOptionsModal.classList.add('show'); // Return to saved options modal
            }
        });

        function closeDieActionChoiceModal() {
            dieActionChoiceModal.classList.remove('show');
            tempSavedDieOptions = null;
        }


        // --- Spinner Logic (Roulette Wheel) ---
        const spinSpinnerBtn = document.getElementById('spinSpinnerBtn');
        const customizeSpinnerBtn = document.getElementById('customizeSpinnerBtn'); // New
        const spinnerResultDisplay = document.getElementById('spinnerResultDisplay');
        
        let spinnerOptions = []; // Will be populated dynamically based on currentCount

        // Helper function to wrap text on canvas
        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let lines = [];

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = context.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    lines.push(line.trim());
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line.trim());

            // Adjust starting Y for vertical centering
            let currentY = y - (lines.length - 1) * lineHeight / 2;
            for (let i = 0; i < lines.length; i++) {
                context.fillText(lines[i], x, currentY + (i * lineHeight));
            }
        }


        // Function to update the visual display of spinners (roulette wheel)
        function updateSpinnerDisplay(results = []) {
            spinnerResultDisplay.innerHTML = ''; // Clear previous spinners

            // Always render one spinner
            const spinnerContainer = document.createElement('div');
            spinnerContainer.classList.add('spinner-container');
            
            const canvas = document.createElement('canvas');
            canvas.width = 250; // Fixed size for drawing
            canvas.height = 250;
            canvas.classList.add('spinner-canvas');
            // canvas.style.transform = 'rotate(0deg)'; // Canvas itself no longer spins
            spinnerContainer.appendChild(canvas);

            // New central spinning pointer element
            const centralSpinnerPointer = document.createElement('div');
            centralSpinnerPointer.classList.add('central-spinner-pointer');
            centralSpinnerPointer.style.transform = `translate(-50%, -100%) rotate(0deg)`; // Initial state
            spinnerContainer.appendChild(centralSpinnerPointer);


            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2;

            // Start drawing from 180 degrees (Math.PI) to visually rotate the wheel
            let startAngle = Math.PI; 
            const sliceAngle = (2 * Math.PI) / currentCount; // Use currentCount for number of parts

            const colors = [
                '#FF6347', '#4682B4', '#3CB371', '#FFD700', '#DA70D6',
                '#FFA07A', '#20B2AA', '#87CEEB'
            ]; // 8 distinct colors

            // Draw slices based on currentCount (number of parts)
            for (let j = 0; j < currentCount; j++) {
                const endAngle = startAngle + sliceAngle;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = colors[j % colors.length]; // Cycle through colors
                ctx.fill();
                ctx.strokeStyle = '#fff'; // White border for slices
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw text: custom option for each slice
                const optionText = spinnerOptions[j] || (j + 1).toString(); // Use custom option or default number
                const textAngle = startAngle + sliceAngle / 2; // Text angle is relative to the slice's position

                ctx.save();
                ctx.translate(centerX + Math.cos(textAngle) * (radius / 2.2), centerY + Math.sin(textAngle) * (radius / 2.2));
                ctx.rotate(textAngle + Math.PI / 2); // Keep text upright relative to the slice
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Inter'; /* Adjusted font for custom text */
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const maxTextWidth = radius * 0.7;
                wrapText(ctx, optionText, 0, 0, maxTextWidth, 16); // Wrap custom text
                ctx.restore();

                startAngle = endAngle;
            }

            // Display result text if already spun, otherwise show placeholder
            const resultTextDiv = document.createElement('div');
            if (results[0]) { // Only one result since there's one spinner
                resultTextDiv.textContent = results[0];
                resultTextDiv.classList.add('spinner-result-text');
            } else {
                resultTextDiv.textContent = '?';
                resultTextDiv.classList.add('spinner-result-text');
                resultTextDiv.style.backgroundColor = 'transparent';
                resultTextDiv.style.color = '#2d3748';
            }
            spinnerContainer.appendChild(resultTextDiv);
            
            spinnerResultDisplay.appendChild(spinnerContainer);

            // Update the title based on currentCount (number of parts)
            spinnerCardTitle.textContent = `Spin a Spinner (${currentCount} Parts)`;
        }

        // Function to update spinner options from input fields (now based on currentCount)
        function updateSpinnerOptions() {
            // If spinnerOptions is empty or doesn't match currentCount, initialize with defaults
            if (spinnerOptions.length !== currentCount) {
                spinnerOptions = Array.from({length: currentCount}, (_, i) => `Option ${i + 1}`);
            }
            if (spinnerCard.classList.contains('card-visible') || spinnerEditModal.classList.contains('show')) {
                updateSpinnerDisplay();
            }
            return true;
        }

        // Event listener for Spin Spinner button
        spinSpinnerBtn.addEventListener('click', () => {
            updateSpinnerOptions(); // Ensure spinnerOptions array is up-to-date with custom text

            const spinnerContainer = spinnerResultDisplay.querySelector('.spinner-container');
            const centralSpinnerPointer = spinnerContainer.querySelector('.central-spinner-pointer');
            const existingResultTextEl = spinnerContainer.querySelector('.spinner-result-text');
            if (existingResultTextEl) existingResultTextEl.remove(); // Remove any previous result text

            // spinnerPostDecisionActions.classList.add('hidden'); // Removed: no longer hiding this div
            spinSpinnerBtn.disabled = true; // Disable button during animation
            customizeSpinnerBtn.disabled = true; // Disable customize button
            changeSpinnerCountBtn.disabled = true; // Disable change parts button
            returnToMenuFromSpinner.disabled = true; // Disable return to menu button

            const chosenIndex = Math.floor(Math.random() * currentCount); // Random index
            const chosenOption = spinnerOptions[chosenIndex]; // Get custom option

            // Calculate the target rotation for the chosen option
            const totalRevolutions = 5; // How many full spins
            const sliceAngle = (2 * Math.PI) / currentCount; // Use currentCount for number of parts
            
            // The pointer is at the top (visually 270 degrees or 3*PI/2 radians on a standard canvas)
            const targetAngleForPointer = 3 * Math.PI / 2;
            // The center of the result slice (relative to 0 radians at the right, WITH initial 180 deg offset)
            const centerOfResultSliceAngle = (Math.PI + chosenIndex * sliceAngle) + (sliceAngle / 2); // Adjusted for initial draw offset
            
            // Calculate the rotation needed to bring the center of the result slice to the pointer's position
            let rotationOffset = targetAngleForPointer - centerOfResultSliceAngle;
            
            // Normalize rotationOffset to be positive and within 0 to 2*PI
            rotationOffset = (rotationOffset % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);
            
            // Add full revolutions for visual effect
            const finalRotation = rotationOffset + (totalRevolutions * 2 * Math.PI);

            // Apply initial reset (no transition)
            centralSpinnerPointer.style.transition = 'none';
            centralSpinnerPointer.style.transform = `translate(-50%, -100%) rotate(0deg)`;
            void centralSpinnerPointer.offsetWidth; // Trigger reflow

            // Apply the spinning animation to the central pointer
            centralSpinnerPointer.style.transition = `transform 3s ease-out`;
            centralSpinnerPointer.style.transform = `translate(-50%, -100%) rotate(${finalRotation}rad)`;

            setTimeout(() => {
                centralSpinnerPointer.style.transition = 'none'; // Remove transition after it's done

                // Display the result text overlay
                const finalResultTextDiv = document.createElement('div');
                finalResultTextDiv.textContent = chosenOption;
                finalResultTextDiv.classList.add('spinner-result-text');
                spinnerContainer.appendChild(finalResultTextDiv);

                spinSpinnerBtn.disabled = false;
                customizeSpinnerBtn.disabled = false; // Re-enable customize button
                changeSpinnerCountBtn.disabled = false; // Re-enable change parts button
                returnToMenuFromSpinner.disabled = false; // Re-enable return to menu button
                showResultSplashScreen(chosenOption, () => {
                    // spinnerPostDecisionActions.classList.remove('hidden'); // Removed: no longer hiding this div
                });
            }, 3000); // Match animation duration
        });


        // --- Spinner Edit Modal Logic ---
        const spinnerEditModal = document.getElementById('spinnerEditModal');
        const spinnerEditModalTitle = document.getElementById('spinnerEditModalTitle');
        const modalSpinnerOptionInputsContainer = document.getElementById('modalSpinnerOptionInputs'); // Container for inputs
        const saveSpinnerOptionsBtn = document.getElementById('saveSpinnerOptionsBtn');
        const cancelSpinnerOptionsBtn = document.getElementById('cancelSpinnerOptionsBtn');
        const prevSpinnerModalBtn = document.getElementById('prevSpinnerModalBtn');
        const nextSpinnerModalBtn = document.getElementById('nextSpinnerModalBtn');
        const saveCurrentSpinnerOptionsBtn = document.getElementById('saveCurrentSpinnerOptionsBtn'); // New
        const deleteSavedSpinnerOptionsBtn = document.getElementById('deleteSavedSpinnerOptionsBtn'); // New
        const spinnerSaveSlotsContainerInModal = document.getElementById('spinnerSaveSlotsContainerInModal'); // New

        let editingSpinnerPartIndex = -1; // To keep track of which part is being edited
        let isDeletingSavedSpinner = false; // New state for delete mode

        function openSpinnerEditModal(index) {
            editingSpinnerPartIndex = index;
            // Dynamically create inputs based on currentCount
            modalSpinnerOptionInputsContainer.innerHTML = '';
            spinnerOptions.forEach((option, i) => {
                const inputDiv = document.createElement('div');
                inputDiv.innerHTML = `
                    <label for="modalSpinnerOption${i + 1}" class="block text-gray-700 text-sm font-semibold mb-1">Part ${i + 1}:</label>
                    <input type="text" id="modalSpinnerOption${i + 1}" value="${option}"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-fuchsia-500">
                `;
                modalSpinnerOptionInputsContainer.appendChild(inputDiv);
            });
            
            spinnerEditModalTitle.textContent = `Edit Options for Spinner (Part ${index + 1})`; // Update modal title
            
            // Manage navigation button visibility within the modal
            prevSpinnerModalBtn.style.display = (editingSpinnerPartIndex === 0) ? 'none' : 'block';
            nextSpinnerModalBtn.style.display = (editingSpinnerPartIndex === currentCount - 1) ? 'none' : 'block';

            // Highlight the current input field
            document.getElementById(`modalSpinnerOption${editingSpinnerPartIndex + 1}`).focus();

            renderSpinnerSaveSlotsInModal(); // Render saved slots inside the modal
            spinnerEditModal.classList.add('show');
        }

        function closeSpinnerEditModal() {
            spinnerEditModal.classList.remove('show');
            editingSpinnerPartIndex = -1;
            isDeletingSavedSpinner = false; // Reset delete mode on close
        }

        saveSpinnerOptionsBtn.addEventListener('click', () => {
            if (editingSpinnerPartIndex !== -1) {
                const newOptions = Array.from(modalSpinnerOptionInputsContainer.querySelectorAll('input')).map(input => input.value.trim());
                if (newOptions.every(option => option !== '') && newOptions.length === currentCount) {
                    spinnerOptions = newOptions;
                    showMessage(`Spinner options saved!`, "info");
                } else {
                    showMessage(`Please provide a value for all ${currentCount} parts of the spinner.`, "error");
                    return; // Don't close modal if validation fails
                }
            }
            closeSpinnerEditModal();
            updateSpinnerDisplay(); // Redraw spinner with potentially updated text
        });

        cancelSpinnerOptionsBtn.addEventListener('click', closeSpinnerEditModal);

        // Event listener for the main "Customize" button
        customizeSpinnerBtn.addEventListener('click', () => {
            if (currentCount > 0) {
                openSpinnerEditModal(0); // Open modal for the first part
            } else {
                showMessage("Please select the number of spinner parts first.", "info");
            }
        });

        // Navigation for spinner parts *within the modal*
        prevSpinnerModalBtn.addEventListener('click', () => {
            if (editingSpinnerPartIndex > 0) {
                // Save current edits before navigating
                const newOptions = Array.from(modalSpinnerOptionInputsContainer.querySelectorAll('input')).map(input => input.value.trim());
                if (newOptions.every(option => option !== '') && newOptions.length === currentCount) {
                    spinnerOptions = newOptions;
                } else {
                    showMessage("Please save or cancel current spinner edits before navigating.", "error");
                    return;
                }
                openSpinnerEditModal(editingSpinnerPartIndex - 1);
            }
        });

        nextSpinnerModalBtn.addEventListener('click', () => {
            if (editingSpinnerPartIndex < currentCount - 1) {
                // Save current edits before navigating
                const newOptions = Array.from(modalSpinnerOptionInputsContainer.querySelectorAll('input')).map(input => input.value.trim());
                if (newOptions.every(option => option !== '') && newOptions.length === currentCount) {
                    spinnerOptions = newOptions;
                } else {
                    showMessage("Please save or cancel current spinner edits before navigating.", "error");
                    return;
                }
                openSpinnerEditModal(editingSpinnerPartIndex + 1);
            }
        });

        // Close modal on outside click
        spinnerEditModal.addEventListener('click', (event) => {
            if (event.target === spinnerEditModal) {
                closeSpinnerEditModal();
            }
        });


        // --- Saved Spinner Slots Logic ---
        let savedSpinnerSlots = []; // Array to store saved spinner options

        function loadSavedSpinnerSlots() {
            const savedData = localStorage.getItem('decidoSpinnerSlots');
            if (savedData) {
                savedSpinnerSlots = JSON.parse(savedData);
            } else {
                savedSpinnerSlots = [];
            }
        }

        function saveSpinnerSlotsToLocalStorage() {
            localStorage.setItem('decidoSpinnerSlots', JSON.stringify(savedSpinnerSlots));
        }

        function renderSpinnerSaveSlotsInModal() {
            spinnerSaveSlotsContainerInModal.innerHTML = '';
            if (savedSpinnerSlots.length === 0) {
                spinnerSaveSlotsContainerInModal.innerHTML = '<p class="text-sm text-gray-600">No saved options yet.</p>';
                document.getElementById('deleteSavedSpinnerOptionsBtn').disabled = true; // Disable delete button if no slots
            } else {
                document.getElementById('deleteSavedSpinnerOptionsBtn').disabled = false;
            }

            savedSpinnerSlots.forEach((slot, index) => {
                const savedSpinnerButton = document.createElement('button');
                savedSpinnerButton.classList.add('saved-slot-btn', 'saved-spinner-slot-btn', 'text-sm', 'font-medium', 'py-2', 'px-3', 'rounded-lg', 'border', 'border-fuchsia-200', 'w-full', 'mb-2');
                savedSpinnerButton.textContent = `${slot.name}: ${slot.options.join(', ')}`;
                savedSpinnerButton.dataset.slotIndex = index;

                if (isDeletingSavedSpinner) {
                    savedSpinnerButton.classList.add('delete-mode');
                    savedSpinnerButton.addEventListener('click', (event) => {
                        const idxToDelete = parseInt(event.target.dataset.slotIndex, 10);
                        if (confirm(`Are you sure you want to delete "${savedSpinnerSlots[idxToDelete].name}"?`)) {
                            savedSpinnerSlots.splice(idxToDelete, 1);
                            saveSpinnerSlotsToLocalStorage();
                            renderSpinnerSaveSlotsInModal(); // Re-render the list
                            showMessage("Saved spinner option deleted!", "info");
                        }
                    });
                } else {
                    savedSpinnerButton.addEventListener('click', (event) => {
                        const slotIndex = parseInt(event.target.dataset.slotIndex, 10);
                        // Check if the number of saved options matches the current spinner's part count
                        if (editingSpinnerPartIndex !== -1 && savedSpinnerSlots[slotIndex].options.every(option => option !== '') && savedSpinnerSlots[slotIndex].options.length === currentCount) {
                            spinnerOptions = [ ...savedSpinnerSlots[slotIndex].options ]; // Load a copy of options
                            // Update modal inputs with recalled options
                            Array.from(modalSpinnerOptionInputsContainer.querySelectorAll('input')).forEach((input, i) => {
                                input.value = spinnerOptions[i];
                            });
                            showMessage(`Options from "${savedSpinnerSlots[slotIndex].name}" recalled for Spinner!`, "info");
                        } else if (savedSpinnerSlots[slotIndex].options.length !== currentCount) {
                            showMessage(`Cannot recall. Saved slot has ${savedSpinnerSlots[slotIndex].options.length} options, but current spinner has ${currentCount} parts.`, "error");
                        }
                        else {
                            showMessage("No valid options saved in this slot to recall.", "error");
                        }
                    });
                }
                spinnerSaveSlotsContainerInModal.appendChild(savedSpinnerButton);
            });
            // Update the text of the delete button
            document.getElementById('deleteSavedSpinnerOptionsBtn').textContent = isDeletingSavedSpinner ? 'Cancel Delete' : 'Delete Saved';
        }

        // Function to render the saved spinners list in the central saved options modal
        function renderSavedSpinnersList() {
            savedSpinnersList.innerHTML = '';
            if (savedSpinnerSlots.length === 0) {
                savedSpinnersList.innerHTML = '<p class="text-sm text-gray-600">No saved spinners yet.</p>';
            }
            savedSpinnerSlots.forEach((slot, index) => {
                const slotWrapper = document.createElement('div');
                slotWrapper.classList.add('flex', 'items-center', 'justify-between', 'gap-2', 'w-full', 'mb-2');

                const savedSpinnerButton = document.createElement('button');
                savedSpinnerButton.classList.add('saved-slot-btn', 'saved-spinner-slot-btn', 'text-sm', 'font-medium', 'py-2', 'px-3', 'rounded-lg', 'border', 'border-fuchsia-200', 'flex-grow');
                savedSpinnerButton.textContent = `${slot.name}: ${slot.options.join(', ')}`;
                savedSpinnerButton.dataset.slotIndex = index;
                savedSpinnerButton.addEventListener('click', () => {
                    // When clicked, load these options into Spinner and open its edit modal
                    currentCount = slot.options.length; // Set currentCount to match saved spinner
                    spinnerOptions = [ ...slot.options ];
                    closeSavedOptionsModal();
                    showCard(spinnerCard); // Go to spinner card
                    openSpinnerEditModal(0); // Open edit modal for spinner
                    showMessage(`Options from "${slot.name}" loaded into Spinner!`, "info");
                });
                slotWrapper.appendChild(savedSpinnerButton);

                const deleteButton = document.createElement('button');
                deleteButton.classList.add('delete-saved-option-btn');
                deleteButton.textContent = 'x';
                deleteButton.dataset.slotIndex = index;
                deleteButton.addEventListener('click', (event) => {
                    const idxToDelete = parseInt(event.target.dataset.slotIndex, 10);
                    if (confirm(`Are you sure you want to delete "${savedSpinnerSlots[idxToDelete].name}"?`)) {
                        savedSpinnerSlots.splice(idxToDelete, 1);
                        saveSpinnerSlotsToLocalStorage();
                        renderSavedSpinnersList(); // Re-render the list
                        showMessage("Saved spinner option deleted!", "info");
                    }
                });
                savedSpinnersList.appendChild(slotWrapper);
            });
        }

        // Event listener for the "Save Current Spinner" button inside the modal
        saveCurrentSpinnerOptionsBtn.addEventListener('click', () => {
            if (editingSpinnerPartIndex !== -1) {
                const currentOptions = Array.from(modalSpinnerOptionInputsContainer.querySelectorAll('input')).map(input => input.value.trim());
                if (currentOptions.every(option => option !== '') && currentOptions.length === currentCount) {
                    const saveName = prompt("Name this saved spinner option (e.g., 'Food Choices', 'Activity Ideas'):");
                    if (saveName) {
                        const newSavedOption = {
                            name: saveName.trim(),
                            options: currentOptions
                        };
                        const existingIndex = savedSpinnerSlots.findIndex(slot => slot.name === newSavedOption.name);
                        if (existingIndex !== -1) {
                            savedSpinnerSlots[existingIndex] = newSavedOption;
                            showMessage(`Updated saved options for "${newSavedOption.name}"!`, "info");
                        } else {
                            savedSpinnerSlots.push(newSavedOption);
                            showMessage(`Saved options "${newSavedOption.name}"!`, "info");
                        }
                        saveSpinnerSlotsToLocalStorage();
                        renderSpinnerSaveSlotsInModal(); // Update display of saved slots
                    } else {
                        showMessage("Save operation cancelled. Please provide a name.", "info");
                    }
                } else {
                    showMessage(`Please provide a value for all ${currentCount} parts of the spinner before saving.`, "error");
                }
            } else {
                showMessage("No spinner is currently being edited.", "error");
            }
        });


        // Initial calls for cleaner start if cards are initially visible
        if (spinnerCard.classList.contains('card-visible')) {
            // Initialize spinnerOptions for the new count if needed
            if (spinnerOptions.length !== currentCount) {
                spinnerOptions = Array.from({length: currentCount}, (_, i) => `Option ${i + 1}`);
            }
            updateSpinnerDisplay();
            loadSavedSpinnerSlots(); // Load saved slots on spinner card display
        }
        if (coinCard.classList.contains('card-visible')) {
            // Initialize coinOptions for the new count if needed
            if (coinOptions.length !== currentCount) {
                coinOptions = Array.from({length: currentCount}, () => ({heads: "Heads", tails: "Tails"}));
            }
            updateCoinDisplay();
            loadSavedCoinSlots(); // Load saved slots on coin card display
        }
        if (dieCard.classList.contains('card-visible')) {
            // Initialize dieOptions for the new count if needed
            if (dieOptions.length !== currentCount) {
                dieOptions = Array.from({length: currentCount}, () => ({faces: ["1", "2", "3", "4", "5", "6"]}));
            }
            updateDieDisplay();
            loadSavedDieSlots(); // Load saved slots on die card display
        }
    </script>
</body>
</html>
