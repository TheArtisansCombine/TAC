<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decido - Let Fate Decide!</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f4f8; /* Light blue-gray background */
            margin: 0;
        }
        /* Custom message box styling (instead of alert()) */
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50; /* Green */
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
            font-weight: 600;
        }
        .message-box.show {
            opacity: 1;
        }

        /* Basic animation for coin flip and die roll - placeholder for now */
        .decision-display {
            min-height: 12rem; /* Ensure space for animation */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1.5rem; /* Space between multiple coins/dice/spinners */
            flex-wrap: wrap; /* Allow items to wrap on smaller screens */
            font-size: 2.5rem;
            font-weight: 700;
            color: #2d3748; /* Darker text */
        }

        /* CSS for the coin flip animation */
        .coin {
            width: 80px;
            height: 80px;
            background-color: #fcd34d; /* Gold-like color */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 700;
            color: #3b444b;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            position: relative;
            transform-style: preserve-3d;
            animation: none; /* Controlled by JS */
            cursor: pointer; /* Indicate it's clickable */
            border: 2px solid transparent; /* Subtle border for hover */
            transition: border-color 0.2s ease-in-out;
        }
        .coin:hover {
            border-color: #d97706; /* Amber-600 on hover */
        }
        /* Removed .coin.selected style */

        .coin.flipping {
            animation: flip 1s ease-out forwards;
        }

        @keyframes flip {
            0% { transform: rotateX(0deg); }
            50% { transform: rotateX(1800deg); } /* Multiple spins */
            100% { transform: rotateX(3600deg); }
        }

        /* CSS for the die roll animation (simple version) */
        .die {
            width: 80px;
            height: 80px;
            background-color: #e2e8f0; /* Light gray */
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: 700;
            color: #2d3748;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            animation: none; /* Controlled by JS */
            cursor: pointer; /* Indicate it's clickable */
            border: 2px solid transparent; /* Subtle border for hover */
            transition: border-color 0.2s ease-in-out;
        }
        .die:hover {
            border-color: #3b82f6; /* Blue-500 on hover */
        }

        .die.rolling {
            animation: roll 0.5s infinite linear;
        }

        @keyframes roll {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* CSS for the spinner container (now holds canvas and pointer) */
        .spinner-container {
            position: relative;
            width: 250px; /* Larger size for the wheel */
            height: 250px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            background-color: transparent; /* Background for visibility */
        }

        .spinner-canvas {
            position: absolute;
            top: 0;
            left: 0;
            transition: transform 3s ease-out; /* Smooth spin transition */
        }

        .spinner-pointer {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 15px solid transparent; /* Larger pointer */
            border-right: 15px solid transparent;
            border-bottom: 25px solid #dc2626; /* Red pointer, now pointing down */
            top: -15px; /* Position above the canvas */
            left: 50%;
            transform: translateX(-50%);
            z-index: 10; /* Ensure pointer is on top */
        }

        /* Optional: Styles for the result text overlay */
        .spinner-result-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 1.2rem; /* Adjusted for larger wheel */
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 6px 12px;
            border-radius: 8px;
            z-index: 11; /* Ensure text is above pointer */
            word-break: break-word; /* Allow text to wrap */
            max-width: 80%; /* Limit width of text overlay */
            text-align: center;
        }

        /* Transition classes for cards */
        .card-transition {
            transition: opacity 0.5s ease-in-out, max-height 0.5s ease-in-out;
            overflow: hidden;
        }
        .card-hidden {
            opacity: 0;
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
            margin-bottom: 0;
            visibility: hidden; /* Prevent interaction when hidden */
        }
        .card-visible {
            opacity: 1;
            max-height: 1000px; /* Large enough to cover content */
            visibility: visible; /* Make interactable when visible */
        }

        /* Splash Screen Styles */
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Dark overlay */
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            z-index: 2000; /* Above all other content */
            padding: 20px;
            box-sizing: border-box;
            word-break: break-word;
        }

        .splash-screen.show {
            opacity: 1;
            visibility: visible;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative; /* Needed for absolute positioning of arrows */
        }

        /* Arrow button styling within modal */
        .modal-arrow-button {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: #e2e8f0; /* Gray-200 */
            color: #2d3748; /* Gray-800 */
            font-weight: bold;
            padding: 0.5rem 0.8rem;
            border-radius: 9999px; /* Full rounded */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            cursor: pointer;
            font-size: 1.25rem; /* Larger arrow text */
            line-height: 1; /* Align arrow vertically */
        }
        .modal-arrow-button:hover:not(:disabled) {
            background-color: #cbd5e0; /* Gray-300 */
            transform: translateY(-50%) scale(1.05);
        }
        .modal-arrow-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #prevCoinModalBtn, #prevDieModalBtn {
            left: 1rem;
        }
        #nextCoinModalBtn, #nextDieModalBtn {
            right: 1rem;
        }

        /* Saved Slot Button Style */
        .saved-slot-btn {
            background-color: #fcd34d; /* Yellow-300 for coin, adjusted for die */
            color: #3b444b; /* Dark text */
            font-weight: 600;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            cursor: pointer;
            width: 100%; /* Make it fill the container */
            text-align: center;
            border: none;
        }
        .saved-slot-btn:hover {
            background-color: #fbbf24; /* Yellow-400 for coin, adjusted for die */
            transform: translateY(-1px);
        }
        .saved-die-slot-btn {
            background-color: #93c5fd; /* Blue-300 */
            color: #1e3a8a; /* Dark blue text */
        }
        .saved-die-slot-btn:hover {
            background-color: #60a5fa; /* Blue-400 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4 sm:p-6 md:p-8">
    <div class="max-w-4xl w-full bg-white rounded-2xl shadow-xl p-6 sm:p-8 md:p-10 lg:p-12 space-y-8">
        <!-- App Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl sm:text-5xl font-extrabold text-gray-800 tracking-tight mb-2">Decido</h1>
            <p class="text-lg text-gray-600">When you canâ€™t decide, let Decido decide for you.</p>
        </header>

        <!-- Main Card Container -->
        <div id="mainCardContainer">
            <!-- Initial Decision Selection Card -->
            <section id="decisionSelectionCard" class="card-transition card-visible bg-gradient-to-br from-purple-500 to-indigo-600 p-6 sm:p-8 rounded-xl shadow-lg text-white text-center space-y-6">
                <h2 class="text-3xl sm:text-4xl font-bold mb-4">What's your dilemma?</h2>
                <div class="flex flex-col sm:flex-row justify-center gap-4">
                    <button id="showCoinCountBtn"
                            class="bg-white text-purple-700 hover:bg-purple-100 font-bold py-4 px-8 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   text-xl w-full sm:w-auto">
                        Flip a Coin
                    </button>
                    <button id="showDieCountBtn"
                            class="bg-white text-indigo-700 hover:bg-indigo-100 font-bold py-4 px-8 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   text-xl w-full sm:w-auto">
                        Roll a Die
                    </button>
                    <button id="showSpinnerCountBtn"
                            class="bg-white text-fuchsia-700 hover:bg-fuchsia-100 font-bold py-4 px-8 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   text-xl w-full sm:w-auto">
                        Spin a Spinner
                    </button>
                </div>
            </section>

            <!-- Count Selection Card -->
            <section id="countSelectionCard" class="card-transition card-hidden" style="display: none;">
                <div class="bg-gray-100 p-6 sm:p-8 rounded-xl shadow-md border border-gray-200">
                    <h2 id="countSelectionTitle" class="text-3xl font-bold text-gray-800 mb-6 text-center">How many?</h2>
                    <div class="flex justify-center gap-4 mb-6">
                        <!-- Dynamically generated count buttons -->
                    </div>
                    <div class="flex justify-center">
                        <button id="backToMainBtn"
                                class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                       transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                       w-full sm:w-auto text-lg">
                            Back
                        </button>
                    </div>
                </div>
            </section>

            <!-- Coin Flip Section -->
            <section id="coinCard" class="card-transition card-hidden" style="display: none;">
                <div class="bg-yellow-50 p-6 sm:p-8 rounded-xl shadow-md border border-yellow-200">
                    <h2 id="coinCardTitle" class="text-3xl font-bold text-yellow-800 mb-6 text-center">Flip a Coin</h2>

                    <!-- Coin Display and Result -->
                    <div id="coinResultDisplay" class="decision-display mb-8 text-yellow-700">
                        <!-- Coins will be dynamically added here -->
                    </div>

                    <!-- Coin Actions -->
                    <div class="flex flex-col sm:flex-row justify-center gap-4">
                        <button id="flipCoinBtn"
                                class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Flip
                        </button>
                        <button id="customizeCoinBtn"
                                class="bg-yellow-300 hover:bg-yellow-400 text-yellow-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Customize
                        </button>
                    </div>
                    <div id="coinPostDecisionActions" class="flex flex-col sm:flex-row justify-center gap-4 mt-4 hidden">
                        <button id="changeCoinCountBtn"
                                class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Change Count
                        </button>
                        <button id="returnToMenuFromCoin"
                                class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Return to Menu
                        </button>
                    </div>
                </div>
            </section>

            <!-- Die Roll Section -->
            <section id="dieCard" class="card-transition card-hidden" style="display: none;">
                <div class="bg-blue-50 p-6 sm:p-8 rounded-xl shadow-md border border-blue-200">
                    <h2 id="dieCardTitle" class="text-3xl font-bold text-blue-800 mb-6 text-center">Roll a Die</h2>

                    <!-- Die Display and Result -->
                    <div id="dieResultDisplay" class="decision-display mb-8 text-blue-700">
                        <!-- Dice will be dynamically added here -->
                    </div>

                    <!-- Die Actions -->
                    <div class="flex flex-col sm:flex-row justify-center gap-4">
                        <button id="rollDieBtn"
                                class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Roll
                        </button>
                        <button id="customizeDieBtn"
                                class="bg-blue-300 hover:bg-blue-400 text-blue-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Customize
                        </button>
                    </div>
                    <div id="diePostDecisionActions" class="flex flex-col sm:flex-row justify-center gap-4 mt-4 hidden">
                        <button id="changeDieCountBtn"
                                class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Change Count
                        </button>
                        <button id="returnToMenuFromDie"
                                class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Return to Menu
                        </button>
                    </div>
                </div>
            </section>

            <!-- Spinner Section -->
            <section id="spinnerCard" class="card-transition card-hidden" style="display: none;">
                <div class="bg-fuchsia-50 p-6 sm:p-8 rounded-xl shadow-md border border-fuchsia-200">
                    <h2 id="spinnerCardTitle" class="text-3xl font-bold text-fuchsia-800 mb-6 text-center">Spin a Spinner</h2>

                    <!-- Spinner Display and Result -->
                    <div id="spinnerResultDisplay" class="decision-display mb-8 text-fuchsia-700">
                        <!-- Single spinner will be dynamically added here -->
                    </div>

                    <!-- Spinner Actions -->
                    <div class="flex flex-col sm:flex-row justify-center gap-4">
                        <button id="spinSpinnerBtn"
                                class="bg-fuchsia-500 hover:bg-fuchsia-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Spin
                        </button>
                    </div>
                    <div id="spinnerPostDecisionActions" class="flex flex-col sm:flex-row justify-center gap-4 mt-4 hidden">
                        <button id="changeSpinnerCountBtn"
                                class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                                    transition duration-00 ease-in-out transform hover:-translate-y-1 active:scale-95
                                    w-full sm:w-auto text-lg">
                            Change Parts
                        </button>
                        <button id="returnToMenuFromSpinner"
                                class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-3 px-6 rounded-lg shadow-lg
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95
                                   w-full sm:w-auto text-lg">
                            Return to Menu
                        </button>
                    </div>
                </div>
            </section>
        </div>
    </div>

    <!-- Message Box for Alerts -->
    <div id="messageBox" class="message-box"></div>

    <!-- Splash Screen for Result -->
    <div id="resultSplashScreen" class="splash-screen"></div>

    <!-- Coin Edit Modal -->
    <div id="coinEditModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="coinEditModalTitle" class="text-2xl font-bold text-gray-800 mb-4">Edit Coin Options</h3>
            <div class="space-y-4 mb-6">
                <div>
                    <label for="modalCoinOption1" class="block text-gray-700 text-sm font-semibold mb-2">Option 1 (Heads):</label>
                    <input type="text" id="modalCoinOption1"
                           class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500">
                </div>
                <div>
                    <label for="modalCoinOption2" class="block text-gray-700 text-sm font-semibold mb-2">Option 2 (Tails):</label>
                    <input type="text" id="modalCoinOption2"
                           class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500">
                </div>
            </div>
            <!-- Saved Coin Options within Modal -->
            <div class="bg-yellow-100 p-4 rounded-lg mt-6 shadow-inner">
                <h4 class="text-xl font-bold text-yellow-800 mb-4 text-center">Saved Coin Options</h4>
                <button id="saveCurrentCoinOptionsBtn"
                        class="bg-yellow-400 hover:bg-yellow-500 text-white text-sm font-bold py-2 px-4 rounded-lg shadow-md
                               transition duration-200 mb-4">
                    Save Current Coin
                </button>
                <div id="coinSaveSlotsContainerInModal" class="space-y-3">
                    <!-- Saved slots will be dynamically generated here -->
                </div>
            </div>
            <div class="flex justify-between gap-4 mt-6 relative">
                <button id="prevCoinModalBtn"
                        class="modal-arrow-button" style="left: 1rem;">
                    &larr;
                </button>
                <div class="flex gap-4">
                    <button id="saveCoinOptionsBtn"
                            class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-5 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                        Save
                    </button>
                    <button id="cancelCoinOptionsBtn"
                            class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                        Cancel
                    </button>
                </div>
                <button id="nextCoinModalBtn"
                        class="modal-arrow-button" style="right: 1rem;">
                    &rarr;
                </button>
            </div>
        </div>
    </div>

    <!-- Die Edit Modal -->
    <div id="dieEditModal" class="modal-overlay">
        <div class="modal-content">
            <h3 id="dieEditModalTitle" class="text-2xl font-bold text-gray-800 mb-4">Edit Die Options</h3>
            <div class="grid grid-cols-2 gap-4 mb-6">
                <!-- Input fields for 6 die faces -->
                <div>
                    <label for="modalDieOption1" class="block text-gray-700 text-sm font-semibold mb-1">Face 1:</label>
                    <input type="text" id="modalDieOption1"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="modalDieOption2" class="block text-gray-700 text-sm font-semibold mb-1">Face 2:</label>
                    <input type="text" id="modalDieOption2"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="modalDieOption3" class="block text-gray-700 text-sm font-semibold mb-1">Face 3:</label>
                    <input type="text" id="modalDieOption3"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="modalDieOption4" class="block text-gray-700 text-sm font-semibold mb-1">Face 4:</label>
                    <input type="text" id="modalDieOption4"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="modalDieOption5" class="block text-gray-700 text-sm font-semibold mb-1">Face 5:</label>
                    <input type="text" id="modalDieOption5"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="modalDieOption6" class="block text-gray-700 text-sm font-semibold mb-1">Face 6:</label>
                    <input type="text" id="modalDieOption6"
                           class="w-full p-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
            <!-- Saved Die Options within Modal -->
            <div class="bg-blue-100 p-4 rounded-lg mt-6 shadow-inner">
                <h4 class="text-xl font-bold text-blue-800 mb-4 text-center">Saved Die Options</h4>
                <button id="saveCurrentDieOptionsBtn"
                        class="bg-blue-400 hover:bg-blue-500 text-white text-sm font-bold py-2 px-4 rounded-lg shadow-md
                               transition duration-200 mb-4">
                    Save Current Die
                </button>
                <div id="dieSaveSlotsContainerInModal" class="space-y-3">
                    <!-- Saved slots will be dynamically generated here -->
                </div>
            </div>
            <div class="flex justify-between gap-4 mt-6 relative">
                <button id="prevDieModalBtn"
                        class="modal-arrow-button" style="left: 1rem;">
                    &larr;
                </button>
                <div class="flex gap-4">
                    <button id="saveDieOptionsBtn"
                            class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-5 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                        Save
                    </button>
                    <button id="cancelDieOptionsBtn"
                            class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-5 rounded-lg shadow-md
                                   transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95">
                        Cancel
                    </button>
                </div>
                <button id="nextDieModalBtn"
                        class="modal-arrow-button" style="right: 1rem;">
                    &rarr;
                </button>
            </div>
        </div>
    </div>

    <script>
        // Utility function to show a custom message box instead of alert()
        function showMessage(message, type = 'success', duration = 3000) {
            const msgBox = document.getElementById('messageBox');
            msgBox.textContent = message;
            msgBox.className = 'message-box show'; // Reset classes and show
            if (type === 'error') {
                msgBox.style.backgroundColor = '#f44336'; // Red for error
            } else if (type === 'info') {
                msgBox.style.backgroundColor = '#2196F3'; // Blue for info
            } else {
                msgBox.style.backgroundColor = '#4CAF50'; // Green for success
            }

            setTimeout(() => {
                msgBox.classList.remove('show');
            }, duration);
        }

        // --- Splash Screen Logic ---
        const resultSplashScreen = document.getElementById('resultSplashScreen');

        function showResultSplashScreen(result, callback) {
            resultSplashScreen.textContent = result;
            resultSplashScreen.classList.add('show');

            setTimeout(() => {
                resultSplashScreen.classList.remove('show');
                setTimeout(() => { // Small delay to ensure fade-out completes
                    if (callback) callback();
                }, 500); // Match splash screen transition duration
            }, 1500); // Display result for 1.5 seconds
        }


        // --- Card Visibility Management ---
        const decisionSelectionCard = document.getElementById('decisionSelectionCard');
        const countSelectionCard = document.getElementById('countSelectionCard');
        const coinCard = document.getElementById('coinCard');
        const dieCard = document.getElementById('dieCard');
        const spinnerCard = document.getElementById('spinnerCard');

        const showCoinCountBtn = document.getElementById('showCoinCountBtn');
        const showDieCountBtn = document.getElementById('showDieCountBtn');
        const showSpinnerCountBtn = document.getElementById('showSpinnerCountBtn');
        const backToMainBtn = document.getElementById('backToMainBtn');
        const countSelectionTitle = document.getElementById('countSelectionTitle');
        const countButtonsContainer = countSelectionCard.querySelector('.flex.justify-center.gap-4.mb-6');


        // Removed specific "Change to..." buttons
        const returnToMenuFromCoin = document.getElementById('returnToMenuFromCoin'); // New
        const returnToMenuFromDie = document.getElementById('returnToMenuFromDie');   // New
        const returnToMenuFromSpinner = document.getElementById('returnToMenuFromSpinner'); // New

        const changeCoinCountBtn = document.getElementById('changeCoinCountBtn');
        const changeDieCountBtn = document.getElementById('changeDieCountBtn');
        const changeSpinnerCountBtn = document.getElementById('changeSpinnerCountBtn');

        const coinCardTitle = document.getElementById('coinCardTitle');
        const dieCardTitle = document.getElementById('dieCardTitle');
        const spinnerCardTitle = document.getElementById('spinnerCardTitle');


        let currentDecisionType = ''; // 'coin', 'die', or 'spinner'
        let currentCount = 1; // Default count for coins/dice/spinner parts


        function showCard(cardToShow, type = '') {
            // First, process all cards to be hidden
            [decisionSelectionCard, countSelectionCard, coinCard, dieCard, spinnerCard].forEach(card => {
                if (card !== cardToShow) {
                    card.classList.remove('card-visible');
                    card.classList.add('card-hidden');
                    // After the CSS transition completes, set display to 'none'
                    setTimeout(() => {
                        if (card.classList.contains('card-hidden')) { // Only apply if still hidden
                            card.style.display = 'none';
                        }
                    }, 500); // Must match CSS transition duration
                }
            });

            // Then, immediately prepare and show the target card
            cardToShow.style.display = 'block'; // Ensure it's in the flow
            // Small delay to ensure browser registers 'display: block' before animating max-height
            setTimeout(() => {
                cardToShow.classList.remove('card-hidden');
                cardToShow.classList.add('card-visible');
            }, 10);

            if (cardToShow === countSelectionCard) {
                currentDecisionType = type;
                let countOptionsHtml = '';
                if (type === 'coin' || type === 'die') {
                    countSelectionTitle.textContent = `How many ${type === 'coin' ? 'coins' : 'dice'}?`;
                    [1, 2, 3].forEach(c => {
                        countOptionsHtml += `<button class="count-btn bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95 text-lg" data-count="${c}">${c}</button>`;
                    });
                } else if (type === 'spinner') {
                    countSelectionTitle.textContent = `How many parts of the pie chart?`;
                    [2, 3, 4, 5, 6, 8].forEach(c => {
                        countOptionsHtml += `<button class="count-btn bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:-translate-y-1 active:scale-95 text-lg" data-count="${c}">${c}</button>`;
                    });
                }
                countButtonsContainer.innerHTML = countOptionsHtml;
                // Re-attach event listeners for newly created buttons
                countButtonsContainer.querySelectorAll('.count-btn').forEach(button => {
                    button.addEventListener('click', handleCountButtonClick);
                });
            } else if (cardToShow === coinCard) {
                // Initialize coinOptions for the new count if needed
                if (coinOptions.length !== currentCount) {
                    coinOptions = Array.from({length: currentCount}, () => ({heads: "Heads", tails: "Tails"}));
                }
                updateCoinDisplay(); // Ensure display and title are updated when coinCard is shown
                loadSavedCoinSlots(); // Load saved slots on coin card display
            } else if (cardToShow === dieCard) {
                // Initialize dieOptions for the new count if needed
                if (dieOptions.length !== currentCount) {
                    dieOptions = Array.from({length: currentCount}, () => ({faces: ["1", "2", "3", "4", "5", "6"]}));
                }
                updateDieDisplay(); // Ensure display and title are updated when dieCard is shown
                loadSavedDieSlots(); // Load saved slots on die card display
            } else if (cardToShow === spinnerCard) {
                updateSpinnerDisplay(); // Ensure display and title are updated when spinnerCard is shown
            }
        }

        // Central handler for count buttons to avoid re-attaching multiple times
        function handleCountButtonClick(event) {
            currentCount = parseInt(event.target.dataset.count, 10);
            if (currentDecisionType === 'coin') {
                showCard(coinCard);
            } else if (currentDecisionType === 'die') {
                showCard(dieCard);
            } else if (currentDecisionType === 'spinner') {
                showCard(spinnerCard);
            }
        }


        // Event listeners for initial decision selection
        showCoinCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'coin'));
        showDieCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'die'));
        showSpinnerCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'spinner'));
        backToMainBtn.addEventListener('click', () => showCard(decisionSelectionCard));

        // Event listeners for post-decision actions
        returnToMenuFromCoin.addEventListener('click', () => showCard(decisionSelectionCard));
        returnToMenuFromDie.addEventListener('click', () => showCard(decisionSelectionCard));
        returnToMenuFromSpinner.addEventListener('click', () => showCard(decisionSelectionCard));

        changeCoinCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'coin'));
        changeDieCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'die'));
        changeSpinnerCountBtn.addEventListener('click', () => showCard(countSelectionCard, 'spinner'));


        // --- Coin Flip Logic ---
        const flipCoinBtn = document.getElementById('flipCoinBtn');
        const customizeCoinBtn = document.getElementById('customizeCoinBtn');
        const coinResultDisplay = document.getElementById('coinResultDisplay');
        const coinPostDecisionActions = document.getElementById('coinPostDecisionActions');

        let coinOptions = [{heads: "Heads", tails: "Tails"}]; // Default options, now an array of objects

        // Function to update the visual display of coins
        function updateCoinDisplay(results = []) {
            coinResultDisplay.innerHTML = ''; // Clear previous coins
            for (let i = 0; i < currentCount; i++) {
                const coinDiv = document.createElement('div');
                coinDiv.classList.add('coin');
                coinDiv.textContent = results[i] || '?'; // Show result or '?'
                coinDiv.dataset.index = i; // Store index for animation
                coinDiv.addEventListener('click', () => openCoinEditModal(i)); // Add click listener
                // Removed selected class logic
                coinResultDisplay.appendChild(coinDiv);
            }
            // Update the title based on currentCount
            coinCardTitle.textContent = currentCount > 1 ? 'Flip Coins' : 'Flip a Coin';
            // Removed updateCoinNavButtons()
        }

        // Removed updateCoinNavButtons function

        // Event listener for Flip Coin button
        flipCoinBtn.addEventListener('click', () => {
            const coinElements = coinResultDisplay.querySelectorAll('.coin');
            coinPostDecisionActions.classList.add('hidden'); // Hide post-decision actions during flip
            flipCoinBtn.disabled = true; // Disable button during animation
            customizeCoinBtn.disabled = true; // Disable customize button during flip
            // Removed disabling of nav buttons

            const results = []; // Store results for splash screen
            coinElements.forEach((coinEl, index) => {
                const currentCoinOptions = coinOptions[index]; // Get options for this specific coin
                const chosenOption = Math.random() < 0.5 ? currentCoinOptions.heads : currentCoinOptions.tails;
                results.push(chosenOption);

                coinEl.textContent = '?'; // Reset text
                coinEl.classList.add('flipping');

                setTimeout(() => {
                    coinEl.classList.remove('flipping');
                    coinEl.textContent = chosenOption;
                    if (index === coinElements.length - 1) { // Only re-enable after last coin finishes
                        flipCoinBtn.disabled = false;
                        customizeCoinBtn.disabled = false; // Re-enable customize button
                        // Removed re-enabling of nav buttons
                        // Show splash screen with combined results
                        showResultSplashScreen(results.join(', '), () => {
                            coinPostDecisionActions.classList.remove('hidden'); // Show post-decision actions
                        });
                    }
                }, 1000 + (index * 100)); // Stagger animations slightly
            });
        });


        // --- Coin Edit Modal Logic ---
        const coinEditModal = document.getElementById('coinEditModal');
        const coinEditModalTitle = document.getElementById('coinEditModalTitle');
        const modalCoinOption1Input = document.getElementById('modalCoinOption1');
        const modalCoinOption2Input = document.getElementById('modalCoinOption2');
        const saveCoinOptionsBtn = document.getElementById('saveCoinOptionsBtn');
        const cancelCoinOptionsBtn = document.getElementById('cancelCoinOptionsBtn');
        const prevCoinModalBtn = document.getElementById('prevCoinModalBtn');
        const nextCoinModalBtn = document.getElementById('nextCoinModalBtn');
        const saveCurrentCoinOptionsBtn = document.getElementById('saveCurrentCoinOptionsBtn'); // New
        const coinSaveSlotsContainerInModal = document.getElementById('coinSaveSlotsContainerInModal'); // New

        let editingCoinIndex = -1; // To keep track of which coin is being edited

        function openCoinEditModal(index) {
            editingCoinIndex = index;
            modalCoinOption1Input.value = coinOptions[index].heads;
            modalCoinOption2Input.value = coinOptions[index].tails;
            coinEditModalTitle.textContent = `Edit Options for Coin ${index + 1}`; // Update modal title
            
            // Manage navigation button visibility within the modal
            prevCoinModalBtn.style.display = (editingCoinIndex === 0) ? 'none' : 'block';
            nextCoinModalBtn.style.display = (editingCoinIndex === currentCount - 1) ? 'none' : 'block';

            renderCoinSaveSlotsInModal(); // Render saved slots inside the modal
            coinEditModal.classList.add('show');
        }

        function closeCoinEditModal() {
            coinEditModal.classList.remove('show');
            editingCoinIndex = -1;
        }

        saveCoinOptionsBtn.addEventListener('click', () => {
            if (editingCoinIndex !== -1) {
                const opt1 = modalCoinOption1Input.value.trim();
                const opt2 = modalCoinOption2Input.value.trim();
                if (opt1 && opt2) {
                    coinOptions[editingCoinIndex].heads = opt1;
                    coinOptions[editingCoinIndex].tails = opt2;
                    showMessage(`Coin ${editingCoinIndex + 1} options saved!`, "info");
                } else {
                    showMessage("Please provide both options for the coin.", "error");
                    return; // Don't close modal if validation fails
                }
            }
            closeCoinEditModal();
            updateCoinDisplay(); // Redraw coins with potentially updated text
        });

        cancelCoinOptionsBtn.addEventListener('click', closeCoinEditModal);

        // Event listener for the main "Customize" button
        customizeCoinBtn.addEventListener('click', () => {
            if (currentCount > 0) {
                openCoinEditModal(0); // Open modal for the first coin
            } else {
                showMessage("Please select a count of coins first.", "info");
            }
        });

        // Navigation for coins *within the modal*
        prevCoinModalBtn.addEventListener('click', () => {
            if (editingCoinIndex > 0) {
                // Save current edits before navigating
                if (modalCoinOption1Input.value.trim() && modalCoinOption2Input.value.trim()) {
                    coinOptions[editingCoinIndex].heads = modalCoinOption1Input.value.trim();
                    coinOptions[editingCoinIndex].tails = modalCoinOption2Input.value.trim();
                } else {
                    showMessage("Please save or cancel current coin edits before navigating.", "error");
                    return;
                }
                openCoinEditModal(editingCoinIndex - 1);
            }
        });

        nextCoinModalBtn.addEventListener('click', () => {
            if (editingCoinIndex < currentCount - 1) {
                // Save current edits before navigating
                if (modalCoinOption1Input.value.trim() && modalCoinOption2Input.value.trim()) {
                    coinOptions[editingCoinIndex].heads = modalCoinOption1Input.value.trim();
                    coinOptions[editingCoinIndex].tails = modalCoinOption2Input.value.trim();
                } else {
                    showMessage("Please save or cancel current coin edits before navigating.", "error");
                    return;
                }
                openCoinEditModal(editingCoinIndex + 1);
            }
        });


        // --- Saved Coin Slots Logic ---
        let savedCoinSlots = []; // Array to store saved options

        // Function to load saved slots from localStorage
        function loadSavedCoinSlots() {
            const savedData = localStorage.getItem('decidoCoinSlots');
            if (savedData) {
                savedCoinSlots = JSON.parse(savedData);
            } else {
                // Initialize with empty slots if no data found
                savedCoinSlots = []; // Start empty
            }
        }

        // Function to save slots to localStorage
        function saveCoinSlotsToLocalStorage() {
            localStorage.setItem('decidoCoinSlots', JSON.stringify(savedCoinSlots));
        }

        // Function to render the save/recall buttons and their content INSIDE THE MODAL
        function renderCoinSaveSlotsInModal() {
            coinSaveSlotsContainerInModal.innerHTML = ''; // Clear existing
            if (savedCoinSlots.length === 0) {
                coinSaveSlotsContainerInModal.innerHTML = '<p class="text-sm text-gray-600">No saved options yet.</p>';
            }

            savedCoinSlots.forEach((slot, index) => {
                const savedCoinButton = document.createElement('button');
                savedCoinButton.classList.add('saved-slot-btn', 'text-sm', 'font-medium', 'text-yellow-700', 'py-2', 'px-3', 'rounded-lg', 'border', 'border-yellow-200', 'w-full', 'mb-2');
                savedCoinButton.textContent = `${slot.name}: ${slot.options.heads} / ${slot.options.tails}`;
                savedCoinButton.dataset.slotIndex = index;

                savedCoinButton.addEventListener('click', (event) => {
                    const slotIndex = parseInt(event.target.dataset.slotIndex, 10);
                    if (editingCoinIndex !== -1 && savedCoinSlots[slotIndex].options.heads && savedCoinSlots[slotIndex].options.tails) {
                        // Apply recalled options to the currently edited coin
                        coinOptions[editingCoinIndex] = { ...savedCoinSlots[slotIndex].options }; // Load a copy of options
                        // Update modal inputs with recalled options
                        modalCoinOption1Input.value = coinOptions[editingCoinIndex].heads;
                        modalCoinOption2Input.value = coinOptions[editingCoinIndex].tails;
                        showMessage(`Options from "${savedCoinSlots[slotIndex].name}" recalled for Coin ${editingCoinIndex + 1}!`, "info");
                    } else {
                        showMessage("No options saved in this slot to recall.", "error");
                    }
                });
                coinSaveSlotsContainerInModal.appendChild(savedCoinButton);
            });
        }

        // Event listener for the "Save Current Coin" button inside the modal
        saveCurrentCoinOptionsBtn.addEventListener('click', () => {
            if (editingCoinIndex !== -1) {
                const opt1 = modalCoinOption1Input.value.trim();
                const opt2 = modalCoinOption2Input.value.trim();
                if (opt1 && opt2) {
                    const saveName = prompt("Name this saved coin option (e.g., 'Yes/No', 'Coffee/Tea'):");
                    if (saveName) {
                        const newSavedOption = {
                            name: saveName.trim(),
                            options: { heads: opt1, tails: opt2 }
                        };
                        // Check if name already exists and replace, or add new
                        const existingIndex = savedCoinSlots.findIndex(slot => slot.name === newSavedOption.name);
                        if (existingIndex !== -1) {
                            savedCoinSlots[existingIndex] = newSavedOption;
                            showMessage(`Updated saved options for "${newSavedOption.name}"!`, "info");
                        } else {
                            savedCoinSlots.push(newSavedOption);
                            showMessage(`Saved options "${newSavedOption.name}"!`, "info");
                        }
                        saveCoinSlotsToLocalStorage();
                        renderCoinSaveSlotsInModal(); // Update display of saved slots
                    } else {
                        showMessage("Save operation cancelled. Please provide a name.", "info");
                    }
                } else {
                    showMessage("Please provide both options for the coin before saving.", "error");
                }
            } else {
                showMessage("No coin is currently being edited.", "error");
            }
        });


        // --- Die Roll Logic ---
        const rollDieBtn = document.getElementById('rollDieBtn');
        const customizeDieBtn = document.getElementById('customizeDieBtn'); // New
        const dieResultDisplay = document.getElementById('dieResultDisplay');
        const diePostDecisionActions = document.getElementById('diePostDecisionActions');
        
        let dieOptions = [{faces: ["1", "2", "3", "4", "5", "6"]}]; // Default options, now an array of objects

        // Function to update the visual display of dice
        function updateDieDisplay(results = []) {
            dieResultDisplay.innerHTML = ''; // Clear previous dice
            for (let i = 0; i < currentCount; i++) {
                const dieDiv = document.createElement('div');
                dieDiv.classList.add('die');
                dieDiv.textContent = results[i] || '?'; // Show result or '?'
                dieDiv.dataset.index = i; // Store index for animation
                dieDiv.addEventListener('click', () => openDieEditModal(i)); // Add click listener
                dieResultDisplay.appendChild(dieDiv);
            }
            // Update the title based on currentCount
            dieCardTitle.textContent = currentCount > 1 ? 'Roll Dice' : 'Roll a Die';
        }

        // Event listener for Roll Die button
        rollDieBtn.addEventListener('click', () => {
            const dieElements = dieResultDisplay.querySelectorAll('.die');
            diePostDecisionActions.classList.add('hidden'); // Hide post-decision actions during roll
            rollDieBtn.disabled = true; // Disable button during animation
            customizeDieBtn.disabled = true; // Disable customize button during roll

            const results = []; // Store results for splash screen
            dieElements.forEach((dieEl, index) => {
                const currentDieFaces = dieOptions[index].faces; // Get faces for this specific die
                const chosenOption = currentDieFaces[Math.floor(Math.random() * currentDieFaces.length)];
                results.push(chosenOption);

                dieEl.textContent = '?'; // Reset text
                dieEl.classList.add('rolling');

                setTimeout(() => {
                    dieEl.classList.remove('rolling');
                    dieEl.textContent = chosenOption;
                    if (index === dieElements.length - 1) { // Only re-enable after last die finishes
                        rollDieBtn.disabled = false;
                        customizeDieBtn.disabled = false; // Re-enable customize button
                        // Show splash screen with combined results
                        showResultSplashScreen(results.join(', '), () => {
                            diePostDecisionActions.classList.remove('hidden'); // Show post-decision actions
                        });
                    }
                }, 500 + (index * 100)); // Stagger animations slightly
            });
        });

        // --- Die Edit Modal Logic ---
        const dieEditModal = document.getElementById('dieEditModal');
        const dieEditModalTitle = document.getElementById('dieEditModalTitle');
        const modalDieOptionInputs = []; // Array to store references to face input fields
        for (let i = 1; i <= 6; i++) {
            modalDieOptionInputs.push(document.getElementById(`modalDieOption${i}`));
        }
        const saveDieOptionsBtn = document.getElementById('saveDieOptionsBtn');
        const cancelDieOptionsBtn = document.getElementById('cancelDieOptionsBtn');
        const prevDieModalBtn = document.getElementById('prevDieModalBtn');
        const nextDieModalBtn = document.getElementById('nextDieModalBtn');
        const saveCurrentDieOptionsBtn = document.getElementById('saveCurrentDieOptionsBtn'); // New
        const dieSaveSlotsContainerInModal = document.getElementById('dieSaveSlotsContainerInModal'); // New

        let editingDieIndex = -1; // To keep track of which die is being edited

        function openDieEditModal(index) {
            editingDieIndex = index;
            const currentFaces = dieOptions[index].faces;
            modalDieOptionInputs.forEach((input, i) => {
                input.value = currentFaces[i] || (i + 1).toString(); // Populate with current or default
            });
            dieEditModalTitle.textContent = `Edit Options for Die ${index + 1}`; // Update modal title

            // Manage navigation button visibility within the modal
            prevDieModalBtn.style.display = (editingDieIndex === 0) ? 'none' : 'block';
            nextDieModalBtn.style.display = (editingDieIndex === currentCount - 1) ? 'none' : 'block';

            renderDieSaveSlotsInModal(); // Render saved slots inside the modal
            dieEditModal.classList.add('show');
        }

        function closeDieEditModal() {
            dieEditModal.classList.remove('show');
            editingDieIndex = -1;
        }

        saveDieOptionsBtn.addEventListener('click', () => {
            if (editingDieIndex !== -1) {
                const newFaces = modalDieOptionInputs.map(input => input.value.trim());
                if (newFaces.every(face => face !== '')) { // Ensure all faces have a value
                    dieOptions[editingDieIndex].faces = newFaces;
                    showMessage(`Die ${editingDieIndex + 1} options saved!`, "info");
                } else {
                    showMessage("Please provide a value for all 6 faces of the die.", "error");
                    return; // Don't close modal if validation fails
                }
            }
            closeDieEditModal();
            updateDieDisplay(); // Redraw dice with potentially updated text
        });

        cancelDieOptionsBtn.addEventListener('click', closeDieEditModal);

        // Event listener for the main "Customize" button
        customizeDieBtn.addEventListener('click', () => {
            if (currentCount > 0) {
                openDieEditModal(0); // Open modal for the first die
            } else {
                showMessage("Please select a count of dice first.", "info");
            }
        });

        // Navigation for dice *within the modal*
        prevDieModalBtn.addEventListener('click', () => {
            if (editingDieIndex > 0) {
                // Save current edits before navigating
                const newFaces = modalDieOptionInputs.map(input => input.value.trim());
                if (newFaces.every(face => face !== '')) {
                    dieOptions[editingDieIndex].faces = newFaces;
                } else {
                    showMessage("Please save or cancel current die edits before navigating.", "error");
                    return;
                }
                openDieEditModal(editingDieIndex - 1);
            }
        });

        nextDieModalBtn.addEventListener('click', () => {
            if (editingDieIndex < currentCount - 1) {
                // Save current edits before navigating
                const newFaces = modalDieOptionInputs.map(input => input.value.trim());
                if (newFaces.every(face => face !== '')) {
                    dieOptions[editingDieIndex].faces = newFaces;
                } else {
                    showMessage("Please save or cancel current die edits before navigating.", "error");
                    return;
                }
                openDieEditModal(editingDieIndex + 1);
            }
        });

        // --- Saved Die Slots Logic ---
        let savedDieSlots = []; // Array to store saved die options

        function loadSavedDieSlots() {
            const savedData = localStorage.getItem('decidoDieSlots');
            if (savedData) {
                savedDieSlots = JSON.parse(savedData);
            } else {
                savedDieSlots = [];
            }
        }

        function saveDieSlotsToLocalStorage() {
            localStorage.setItem('decidoDieSlots', JSON.stringify(savedDieSlots));
        }

        function renderDieSaveSlotsInModal() {
            dieSaveSlotsContainerInModal.innerHTML = '';
            if (savedDieSlots.length === 0) {
                dieSaveSlotsContainerInModal.innerHTML = '<p class="text-sm text-gray-600">No saved options yet.</p>';
            }

            savedDieSlots.forEach((slot, index) => {
                const savedDieButton = document.createElement('button');
                savedDieButton.classList.add('saved-slot-btn', 'saved-die-slot-btn', 'text-sm', 'font-medium', 'py-2', 'px-3', 'rounded-lg', 'border', 'border-blue-200', 'w-full', 'mb-2');
                savedDieButton.textContent = `${slot.name}: ${slot.options.faces.join(', ')}`;
                savedDieButton.dataset.slotIndex = index;

                savedDieButton.addEventListener('click', (event) => {
                    const slotIndex = parseInt(event.target.dataset.slotIndex, 10);
                    if (editingDieIndex !== -1 && savedDieSlots[slotIndex].options.faces.every(face => face !== '')) {
                        dieOptions[editingDieIndex] = { ...savedDieSlots[slotIndex].options };
                        modalDieOptionInputs.forEach((input, i) => {
                            input.value = dieOptions[editingDieIndex].faces[i];
                        });
                        showMessage(`Options from "${savedDieSlots[slotIndex].name}" recalled for Die ${editingDieIndex + 1}!`, "info");
                    } else {
                        showMessage("No valid options saved in this slot to recall.", "error");
                    }
                });
                dieSaveSlotsContainerInModal.appendChild(savedDieButton);
            });
        }

        // Event listener for the "Save Current Die" button inside the modal
        saveCurrentDieOptionsBtn.addEventListener('click', () => {
            if (editingDieIndex !== -1) {
                const currentFaces = modalDieOptionInputs.map(input => input.value.trim());
                if (currentFaces.every(face => face !== '')) {
                    const saveName = prompt("Name this saved die option (e.g., 'D&D', 'Yes/No/Maybe'):");
                    if (saveName) {
                        const newSavedOption = {
                            name: saveName.trim(),
                            options: { faces: currentFaces }
                        };
                        const existingIndex = savedDieSlots.findIndex(slot => slot.name === newSavedOption.name);
                        if (existingIndex !== -1) {
                            savedDieSlots[existingIndex] = newSavedOption;
                            showMessage(`Updated saved options for "${newSavedOption.name}"!`, "info");
                        } else {
                            savedDieSlots.push(newSavedOption);
                            showMessage(`Saved options "${newSavedOption.name}"!`, "info");
                        }
                        saveDieSlotsToLocalStorage();
                        renderDieSaveSlotsInModal();
                    } else {
                        showMessage("Save operation cancelled. Please provide a name.", "info");
                    }
                } else {
                    showMessage("Please provide a value for all 6 faces of the die before saving.", "error");
                }
            } else {
                showMessage("No die is currently being edited.", "error");
            }
        });


        // --- Spinner Logic (Roulette Wheel) ---
        const spinSpinnerBtn = document.getElementById('spinSpinnerBtn');
        const spinnerResultDisplay = document.getElementById('spinnerResultDisplay');
        const spinnerPostDecisionActions = document.getElementById('spinnerPostDecisionActions');

        // Spinner options are now implicitly numbers 1 to currentCount
        let spinnerOptions = []; // Will be populated dynamically

        // Helper function to wrap text on canvas
        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let lines = [];

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = context.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    lines.push(line.trim());
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            lines.push(line.trim());

            // Adjust starting Y for vertical centering
            let currentY = y - (lines.length - 1) * lineHeight / 2;
            for (let i = 0; i < lines.length; i++) {
                context.fillText(lines[i], x, currentY + (i * lineHeight));
            }
        }


        // Function to update the visual display of spinners (roulette wheel)
        function updateSpinnerDisplay(results = []) {
            spinnerResultDisplay.innerHTML = ''; // Clear previous spinners

            // Always render one spinner
            const spinnerContainer = document.createElement('div');
            spinnerContainer.classList.add('spinner-container');
            
            const canvas = document.createElement('canvas');
            canvas.width = 250; // Fixed size for drawing
            canvas.height = 250;
            canvas.classList.add('spinner-canvas');
            canvas.style.transform = 'rotate(0deg)'; // Initial state
            spinnerContainer.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2;

            // Start drawing from 180 degrees (Math.PI) to visually rotate the wheel
            let startAngle = Math.PI; 
            const sliceAngle = (2 * Math.PI) / currentCount; // Use currentCount for number of parts

            const colors = [
                '#FF6347', '#4682B4', '#3CB371', '#FFD700', '#DA70D6',
                '#FFA07A', '#20B2AA', '#87CEEB'
            ]; // 8 distinct colors

            // Draw slices based on currentCount (number of parts)
            for (let j = 0; j < currentCount; j++) {
                const endAngle = startAngle + sliceAngle;

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = colors[j % colors.length]; // Cycle through colors
                ctx.fill();
                ctx.strokeStyle = '#fff'; // White border for slices
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw text: number for each slice
                const optionText = (j + 1).toString(); // Display number
                const textAngle = startAngle + sliceAngle / 2; // Text angle is relative to the slice's position

                ctx.save();
                ctx.translate(centerX + Math.cos(textAngle) * (radius / 2.2), centerY + Math.sin(textAngle) * (radius / 2.2));
                ctx.rotate(textAngle + Math.PI / 2); // Keep text upright relative to the slice
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px Inter'; /* Larger font for numbers */
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(optionText, 0, 0); // No wrapping needed for numbers
                ctx.restore();

                startAngle = endAngle;
            }

            // Draw the pointer
            const pointer = document.createElement('div');
            pointer.classList.add('spinner-pointer');
            spinnerContainer.appendChild(pointer);

            // Display result text if already spun, otherwise show placeholder
            const resultTextDiv = document.createElement('div');
            if (results[0]) { // Only one result since there's one spinner
                resultTextDiv.textContent = results[0];
                resultTextDiv.classList.add('spinner-result-text');
            } else {
                resultTextDiv.textContent = '?';
                resultTextDiv.classList.add('spinner-result-text');
                resultTextDiv.style.backgroundColor = 'transparent';
                resultTextDiv.style.color = '#2d3748';
            }
            spinnerContainer.appendChild(resultTextDiv);
            
            spinnerResultDisplay.appendChild(spinnerContainer);

            // Update the title based on currentCount (number of parts)
            spinnerCardTitle.textContent = `Spin a Spinner (${currentCount} Parts)`;
        }

        // Function to update spinner options (now implicitly numbers 1 to currentCount)
        function updateSpinnerOptions() {
            spinnerOptions = Array.from({length: currentCount}, (_, i) => (i + 1).toString());
            if (spinnerCard.classList.contains('card-visible')) {
                updateSpinnerDisplay();
            }
            return true;
        }

        // Event listener for Spin Spinner button
        spinSpinnerBtn.addEventListener('click', () => {
            updateSpinnerOptions(); // Ensure spinnerOptions array is up-to-date with numbers

            const spinnerContainer = spinnerResultDisplay.querySelector('.spinner-container');
            const canvasEl = spinnerContainer.querySelector('.spinner-canvas');
            const existingResultTextEl = spinnerContainer.querySelector('.spinner-result-text');
            if (existingResultTextEl) existingResultTextEl.remove(); // Remove any previous result text

            spinnerPostDecisionActions.classList.add('hidden'); // Hide post-decision actions during spin
            spinSpinnerBtn.disabled = true; // Disable button during animation

            const chosenNumber = Math.floor(Math.random() * currentCount) + 1; // Random number from 1 to currentCount
            const chosenOption = chosenNumber.toString(); // Convert to string for consistency with results

            // Calculate the target rotation for the chosen option
            const totalRevolutions = 5; // How many full spins
            const sliceAngle = (2 * Math.PI) / currentCount; // Use currentCount for number of parts
            const resultIndex = chosenNumber - 1; // Index is 0-based

            // The pointer is at the top (visually 270 degrees or 3*PI/2 radians on a standard canvas)
            const targetAngleForPointer = 3 * Math.PI / 2;
            // The center of the result slice (relative to 0 radians at the right, WITH initial 180 deg offset)
            const centerOfResultSliceAngle = (Math.PI + resultIndex * sliceAngle) + (sliceAngle / 2); // Adjusted for initial draw offset
            
            // Calculate the rotation needed to bring the center of the result slice to the pointer's position
            let rotationOffset = targetAngleForPointer - centerOfResultSliceAngle;
            
            // Normalize rotationOffset to be positive and within 0 to 2*PI
            rotationOffset = (rotationOffset % (2 * Math.PI) + (2 * Math.PI)) % (2 * Math.PI);
            
            // Add full revolutions for visual effect
            const finalRotation = rotationOffset + (totalRevolutions * 2 * Math.PI);

            // Apply initial reset (no transition)
            canvasEl.style.transition = 'none';
            canvasEl.style.transform = `rotate(0deg)`;
            void canvasEl.offsetWidth; // Trigger reflow

            // Apply the spinning animation
            canvasEl.style.transition = `transform 3s ease-out`;
            canvasEl.style.transform = `rotate(${finalRotation}rad)`;

            setTimeout(() => {
                canvasEl.style.transition = 'none'; // Remove transition after it's done

                // Display the result text overlay
                const finalResultTextDiv = document.createElement('div');
                finalResultTextDiv.textContent = chosenOption;
                finalResultTextDiv.classList.add('spinner-result-text');
                spinnerContainer.appendChild(finalResultTextDiv);

                spinSpinnerBtn.disabled = false;
                showResultSplashScreen(chosenOption, () => {
                    spinnerPostDecisionActions.classList.remove('hidden'); // Show post-decision actions
                });
            }, 3000); // Match animation duration
        });

        // Initial calls for cleaner start if cards are initially visible
        if (spinnerCard.classList.contains('card-visible')) {
            updateSpinnerOptions(); // Ensure spinnerOptions are set for initial display
            updateSpinnerDisplay();
        }
        if (coinCard.classList.contains('card-visible')) {
            // Initialize coinOptions for the new count if needed
            if (coinOptions.length !== currentCount) {
                coinOptions = Array.from({length: currentCount}, () => ({heads: "Heads", tails: "Tails"}));
            }
            updateCoinDisplay();
            loadSavedCoinSlots(); // Load saved slots on coin card display
        }
        if (dieCard.classList.contains('card-visible')) {
            // Initialize dieOptions for the new count if needed
            if (dieOptions.length !== currentCount) {
                dieOptions = Array.from({length: currentCount}, () => ({faces: ["1", "2", "3", "4", "5", "6"]}));
            }
            updateDieDisplay();
            loadSavedDieSlots(); // Load saved slots on die card display
        }
    </script>
</body>
</html>
